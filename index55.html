<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Язык пламени</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <canvas id="flameCanvas"></canvas>
    <div id="controls">
        <div>Интенсивность: <input type="range" id="intensity" min="1" max="10" value="5"></div>
        <div>Высота: <input type="range" id="height" min="50" max="300" value="150"></div>
    </div>

    <script>
        const canvas = document.getElementById('flameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Настройки пламени
        const config = {
            intensity: 5,
            flameHeight: 150,
            baseWidth: 80,
            flickerSpeed: 0.02,
            colorStops: [
                {pos: 0, color: [255, 255, 180, 1]},
                {pos: 0.5, color: [255, 100, 0, 0.8]},
                {pos: 0.9, color: [150, 30, 0, 0.5]},
                {pos: 1, color: [50, 0, 0, 0]}
            ],
            turbulence: 0.3
        };

        // Точки для построения пламени
        const flamePoints = Array.from({length: 30}, (_, i) => ({
            x: 0,
            y: 0,
            noise: Math.random() * 10
        }));

        // Шум Перлина для плавного движения
        function noise(x) {
            return Math.sin(x) * 0.5 + Math.sin(x * 0.3) * 0.3 + Math.sin(x * 0.1) * 0.2;
        }

        // Обновление точек пламени
        function updateFlame(time) {
            const centerX = canvas.width / 2;
            const baseY = canvas.height - 50;
            
            for (let i = 0; i < flamePoints.length; i++) {
                const progress = i / (flamePoints.length - 1);
                const angle = progress * Math.PI;
                
                // Базовые координаты
                const x = centerX + Math.sin(angle) * config.baseWidth / 2;
                const baseYPos = baseY - progress * config.flameHeight;
                
                // Динамические колебания
                flamePoints[i].noise += 0.1;
                const noiseValue = noise(flamePoints[i].noise + time * config.flickerSpeed);
                
                // Формируем язык пламени
                const turbulence = config.turbulence * (1 - progress) * config.intensity;
                flamePoints[i].x = x + noiseValue * turbulence * config.baseWidth;
                flamePoints[i].y = baseYPos - Math.abs(noiseValue) * 30 * progress;
            }
        }

        // Рисование пламени
        function drawFlame() {
            const centerX = canvas.width / 2;
            const baseY = canvas.height - 50;
            
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            // Рисуем основной язык пламени
            ctx.beginPath();
            ctx.moveTo(centerX - config.baseWidth/2, baseY);
            
            // Верхняя часть пламени
            for (let i = 0; i < flamePoints.length; i++) {
                ctx.lineTo(flamePoints[i].x, flamePoints[i].y);
            }
            
            ctx.lineTo(centerX + config.baseWidth/2, baseY);
            ctx.closePath();
            
            // Градиент для пламени
            const gradient = ctx.createLinearGradient(
                centerX, baseY - config.flameHeight,
                centerX, baseY
            );
            
            config.colorStops.forEach(stop => {
                gradient.addColorStop(stop.pos, `rgba(${stop.color.join(',')})`);
            });
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Добавляем мерцающие частицы
            for (let i = 0; i < 20 * config.intensity; i++) {
                const progress = Math.random();
                const angle = progress * Math.PI;
                const x = centerX + Math.sin(angle) * config.baseWidth/2;
                const y = baseY - progress * config.flameHeight;
                
                const size = Math.random() * 8 + 2;
                const alpha = Math.random() * 0.5 + 0.3;
                const hue = config.baseHue || 20 + Math.random() * 10;
                
                ctx.beginPath();
                ctx.arc(
                    x + (Math.random() - 0.5) * 30,
                    y - Math.random() * 20,
                    size,
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${alpha})`;
                ctx.fill();
            }
            
            // Основание огня
            const baseGradient = ctx.createRadialGradient(
                centerX, baseY, 0,
                centerX, baseY, config.baseWidth/2
            );
            baseGradient.addColorStop(0, 'rgba(255, 200, 100, 0.8)');
            baseGradient.addColorStop(1, 'rgba(150, 50, 0, 0)');
            
            ctx.beginPath();
            ctx.arc(centerX, baseY, config.baseWidth/2, 0, Math.PI * 2);
            ctx.fillStyle = baseGradient;
            ctx.fill();
            
            ctx.restore();
        }

        // Анимация
        function animate(time) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            updateFlame(time);
            drawFlame();
            
            requestAnimationFrame(animate);
        }

        // Обработчики контролов
        document.getElementById('intensity').addEventListener('input', (e) => {
            config.intensity = parseInt(e.target.value);
        });
        
        document.getElementById('height').addEventListener('input', (e) => {
            config.flameHeight = parseInt(e.target.value);
        });

        // Ресайз
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Запуск
        animate(0);
    </script>
</body>
</html>
