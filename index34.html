<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–î–æ–≥–æ–Ω—è–ª–∫–∏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        body {
            overflow: hidden;
            background-color: #222;
            font-family: Arial, sans-serif;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        #gameCanvas {
            background-color: #333;
            display: block;
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        #startButton {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #gameTitle {
            color: white;
            font-size: 36px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        #gameInstructions {
            color: #ccc;
            font-size: 16px;
            max-width: 80%;
            text-align: center;
            margin-bottom: 30px;
        }
        
        #joystickContainer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            z-index: 5;
        }
        
        #joystick {
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: relative;
        }
        
        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 30px;
            left: 30px;
        }
        
        #abilitiesContainer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 5;
        }
        
        .abilityButton {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .abilityButton.active {
            border-color: white;
            box-shadow: 0 0 10px white;
        }
        
        #timerContainer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 10px;
            z-index: 5;
        }
        
        #resultScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        
        #resultText {
            color: white;
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        #restartButton {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #timeSurvived {
            color: #4CAF50;
            font-size: 28px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="joystickContainer">
            <div id="joystick">
                <div id="joystickKnob"></div>
            </div>
        </div>
        
        <div id="abilitiesContainer">
            <div class="abilityButton" id="ability1">‚ùå</div>
            <div class="abilityButton" id="ability2">‚ùå</div>
            <div class="abilityButton" id="ability3">‚ùå</div>
            <div class="abilityButton" id="ability4">‚ùå</div>
        </div>
        
        <div id="timerContainer">00:00</div>
        
        <div id="startScreen">
            <h1 id="gameTitle">–î–æ–≥–æ–Ω—è–ª–∫–∏</h1>
            <p id="gameInstructions">
                –£–±–µ–≥–∞–π—Ç–µ –æ—Ç –≤—Ä–∞–≥–∞ 60 —Å–µ–∫—É–Ω–¥!<br>
                –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–∂–æ–π—Å—Ç–∏–∫ —Å–ª–µ–≤–∞ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è.<br>
                –ü–æ–¥–±–∏—Ä–∞–π—Ç–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –Ω–∞ –ø–æ–ª–µ –∏ –∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –∏—Ö –∫–Ω–æ–ø–∫–∞–º–∏ —Å–ø—Ä–∞–≤–∞.<br>
                –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏: —É—Å–∫–æ—Ä–µ–Ω–∏–µ, —Å–±—Ä–æ—Å —è—â–∏–∫–∞, –ø—Ä—ã–∂–æ–∫ –∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Ä–∞–≥–∞.
            </p>
            <button id="startButton">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
        </div>
        
        <div id="resultScreen">
            <h2 id="resultText"></h2>
            <div id="timeSurvived"></div>
            <button id="restartButton">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>
    </div>

    <script>
        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–≥—Ä—ã
        const config = {
            playerSize: 20,
            enemySize: 20,
            boxSize: 30,
            abilitySize: 20,
            playerSpeed: 3,
            enemySpeed: 2.5,
            playerSpeedBoost: 1.3, // +30%
            abilityDuration: 3000, // 3 —Å–µ–∫—É–Ω–¥—ã –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è
            enemyFreezeDuration: 2000, // 2 —Å–µ–∫—É–Ω–¥—ã –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤—Ä–∞–≥–∞
            abilityBlinkDuration: 5000, // 5 —Å–µ–∫—É–Ω–¥ –º–∏–≥–∞–Ω–∏—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
            winTime: 60000, // 60 —Å–µ–∫—É–Ω–¥ –¥–ª—è –ø–æ–±–µ–¥—ã
            boxCount: 15, // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —è—â–∏–∫–æ–≤ –Ω–∞ –∫–∞—Ä—Ç–µ
            abilitySpawnInterval: 10000, // –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ—è–≤–ª–µ–Ω–∏—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π (10 —Å–µ–∫)
            maxAbilities: 4 // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π —É –∏–≥—Ä–æ–∫–∞
        };

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
        const gameState = {
            isRunning: false,
            startTime: 0,
            currentTime: 0,
            player: {
                x: 0,
                y: 0,
                dx: 0,
                dy: 0,
                speed: config.playerSpeed,
                isBoosting: false,
                boostEndTime: 0,
                canDropBox: true,
                canJump: true
            },
            enemy: {
                x: 0,
                y: 0,
                isFrozen: false,
                freezeEndTime: 0
            },
            boxes: [],
            abilities: [],
            playerAbilities: Array(config.maxAbilities).fill(null),
            joystickActive: false,
            joystickAngle: 0,
            joystickDistance: 0,
            canvasSize: {
                width: 0,
                height: 0
            },
            lastAbilitySpawnTime: 0
        };

        // –¢–∏–ø—ã —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
        const AbilityType = {
            SPEED_BOOST: { emoji: "‚ö°", color: "#FFD700", name: "–£—Å–∫–æ—Ä–µ–Ω–∏–µ" },
            DROP_BOX: { emoji: "üì¶", color: "#8B4513", name: "–Ø—â–∏–∫" },
            JUMP: { emoji: "ü¶ò", color: "#00BFFF", name: "–ü—Ä—ã–∂–æ–∫" },
            FREEZE_ENEMY: { emoji: "‚ùÑÔ∏è", color: "#ADD8E6", name: "–ó–∞–º–æ—Ä–æ–∑–∫–∞" }
        };

        // DOM —ç–ª–µ–º–µ–Ω—Ç—ã
        const elements = {
            canvas: document.getElementById("gameCanvas"),
            ctx: null,
            startScreen: document.getElementById("startScreen"),
            startButton: document.getElementById("startButton"),
            joystick: document.getElementById("joystick"),
            joystickKnob: document.getElementById("joystickKnob"),
            abilities: [
                document.getElementById("ability1"),
                document.getElementById("ability2"),
                document.getElementById("ability3"),
                document.getElementById("ability4")
            ],
            timer: document.getElementById("timerContainer"),
            resultScreen: document.getElementById("resultScreen"),
            resultText: document.getElementById("resultText"),
            timeSurvived: document.getElementById("timeSurvived"),
            restartButton: document.getElementById("restartButton")
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        function initGame() {
            elements.ctx = elements.canvas.getContext("2d");
            resizeCanvas();
            window.addEventListener("resize", resizeCanvas);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            initControls();
            
            // –ù–∞—á–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
            elements.startButton.addEventListener("click", startGame);
            elements.restartButton.addEventListener("click", startGame);
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
            elements.abilities.forEach((ability, index) => {
                ability.addEventListener("click", () => useAbility(index));
            });
            
            // –ó–∞–ø—Ä–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é
            document.addEventListener("contextmenu", (e) => e.preventDefault());
        }

        // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ canvas
        function resizeCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            elements.canvas.width = width;
            elements.canvas.height = height;
            
            gameState.canvasSize.width = width;
            gameState.canvasSize.height = height;
            
            if (gameState.isRunning) {
                renderGame();
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        function initControls() {
            // –°–µ–Ω—Å–æ—Ä–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            elements.joystick.addEventListener("touchstart", handleJoystickStart);
            elements.joystick.addEventListener("touchmove", handleJoystickMove);
            elements.joystick.addEventListener("touchend", handleJoystickEnd);
            
            // –ú—ã—à—å –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –ü–ö
            elements.joystick.addEventListener("mousedown", handleJoystickStart);
            document.addEventListener("mousemove", handleJoystickMove);
            document.addEventListener("mouseup", handleJoystickEnd);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞—á–∞–ª–∞ –¥–≤–∏–∂–µ–Ω–∏—è –¥–∂–æ–π—Å—Ç–∏–∫–∞
        function handleJoystickStart(e) {
            e.preventDefault();
            gameState.joystickActive = true;
            updateJoystickPosition(e);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è –¥–∂–æ–π—Å—Ç–∏–∫–∞
        function handleJoystickMove(e) {
            if (gameState.joystickActive) {
                e.preventDefault();
                updateJoystickPosition(e);
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –¥–∂–æ–π—Å—Ç–∏–∫–∞
        function handleJoystickEnd(e) {
            if (gameState.joystickActive) {
                e.preventDefault();
                gameState.joystickActive = false;
                gameState.joystickDistance = 0;
                gameState.player.dx = 0;
                gameState.player.dy = 0;
                positionJoystickKnob(0, 0);
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞
        function updateJoystickPosition(e) {
            const rect = elements.joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let clientX, clientY;
            
            if (e.type.includes("touch")) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const dx = clientX - centerX;
            const dy = clientY - centerY;
            const distance = Math.min(Math.sqrt(dx * dx + dy * dy), rect.width / 2);
            
            const angle = Math.atan2(dy, dx);
            const normalizedDistance = distance / (rect.width / 2);
            
            gameState.joystickAngle = angle;
            gameState.joystickDistance = normalizedDistance;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞
            gameState.player.dx = Math.cos(angle) * normalizedDistance;
            gameState.player.dy = Math.sin(angle) * normalizedDistance;
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä—É—á–∫–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞
            positionJoystickKnob(dx * 0.7, dy * 0.7);
        }

        // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä—É—á–∫–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞
        function positionJoystickKnob(x, y) {
            elements.joystickKnob.style.transform = `translate(${x}px, ${y}px)`;
        }

        // –ù–∞—á–∞–ª–æ –∏–≥—Ä—ã
        function startGame() {
            // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
            resetGameState();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
            initGameObjects();
            
            // –°–∫—Ä—ã—Ç–∏–µ —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ —ç–∫—Ä–∞–Ω–∞ –∏ —ç–∫—Ä–∞–Ω–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            elements.startScreen.style.display = "none";
            elements.resultScreen.style.display = "none";
            
            // –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
            gameState.isRunning = true;
            gameState.startTime = Date.now();
            gameState.lastAbilitySpawnTime = gameState.startTime;
            
            requestAnimationFrame(gameLoop);
        }

        // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
        function resetGameState() {
            gameState.isRunning = false;
            gameState.startTime = 0;
            gameState.currentTime = 0;
            gameState.player = {
                x: 0,
                y: 0,
                dx: 0,
                dy: 0,
                speed: config.playerSpeed,
                isBoosting: false,
                boostEndTime: 0,
                canDropBox: true,
                canJump: true
            };
            gameState.enemy = {
                x: 0,
                y: 0,
                isFrozen: false,
                freezeEndTime: 0
            };
            gameState.boxes = [];
            gameState.abilities = [];
            gameState.playerAbilities = Array(config.maxAbilities).fill(null);
            gameState.joystickActive = false;
            gameState.joystickAngle = 0;
            gameState.joystickDistance = 0;
            gameState.lastAbilitySpawnTime = 0;
            
            // –°–±—Ä–æ—Å –∫–Ω–æ–ø–æ–∫ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
            elements.abilities.forEach(ability => {
                ability.textContent = "‚ùå";
                ability.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
                ability.classList.remove("active");
            });
            
            // –°–±—Ä–æ—Å –¥–∂–æ–π—Å—Ç–∏–∫–∞
            positionJoystickKnob(0, 0);
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
        function initGameObjects() {
            const margin = 50;
            const width = gameState.canvasSize.width - margin * 2;
            const height = gameState.canvasSize.height - margin * 2;
            
            // –ü–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞
            gameState.player.x = margin + width / 4;
            gameState.player.y = margin + height / 2;
            
            // –ü–æ–∑–∏—Ü–∏—è –≤—Ä–∞–≥–∞ (–≤ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–µ)
            gameState.enemy.x = margin + width * 3 / 4;
            gameState.enemy.y = margin + height / 2;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —è—â–∏–∫–æ–≤
            gameState.boxes = [];
            for (let i = 0; i < config.boxCount; i++) {
                let box;
                let overlapping;
                
                // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ —è—â–∏–∫–∏ –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è —Å –∏–≥—Ä–æ–∫–æ–º, –≤—Ä–∞–≥–æ–º –∏–ª–∏ –¥—Ä—É–≥–∏–º–∏ —è—â–∏–∫–∞–º–∏
                do {
                    overlapping = false;
                    box = {
                        x: margin + Math.random() * width,
                        y: margin + Math.random() * height,
                        width: config.boxSize,
                        height: config.boxSize
                    };
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –∏–≥—Ä–æ–∫–æ–º
                    if (checkCollision(
                        box.x - config.playerSize/2, box.y - config.playerSize/2, 
                        box.width + config.playerSize, box.height + config.playerSize,
                        gameState.player.x - config.playerSize/2, gameState.player.y - config.playerSize/2,
                        config.playerSize, config.playerSize
                    )) {
                        overlapping = true;
                        continue;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –≤—Ä–∞–≥–æ–º
                    if (checkCollision(
                        box.x - config.enemySize/2, box.y - config.enemySize/2, 
                        box.width + config.enemySize, box.height + config.enemySize,
                        gameState.enemy.x - config.enemySize/2, gameState.enemy.y - config.enemySize/2,
                        config.enemySize, config.enemySize
                    )) {
                        overlapping = true;
                        continue;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –¥—Ä—É–≥–∏–º–∏ —è—â–∏–∫–∞–º–∏
                    for (const otherBox of gameState.boxes) {
                        if (checkCollision(
                            box.x, box.y, box.width, box.height,
                            otherBox.x, otherBox.y, otherBox.width, otherBox.height
                        )) {
                            overlapping = true;
                            break;
                        }
                    }
                } while (overlapping);
                
                gameState.boxes.push(box);
            }
        }

        // –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function gameLoop() {
            if (!gameState.isRunning) return;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏
            gameState.currentTime = Date.now();
            const elapsedTime = gameState.currentTime - gameState.startTime;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –ø–æ–±–µ–¥—ã/–ø–æ—Ä–∞–∂–µ–Ω–∏—è
            if (elapsedTime >= config.winTime) {
                endGame(true);
                return;
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
            updateGame(elapsedTime);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–≥—Ä—ã
            renderGame();
            
            // –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ —Ü–∏–∫–ª–∞
            requestAnimationFrame(gameLoop);
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
        function updateGame(elapsedTime) {
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞
            updateTimer(elapsedTime);
            
            // –°–ø–∞–≤–Ω –Ω–æ–≤—ã—Ö —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
            if (gameState.currentTime - gameState.lastAbilitySpawnTime > config.abilitySpawnInterval) {
                spawnRandomAbility();
                gameState.lastAbilitySpawnTime = gameState.currentTime;
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä–æ–∫–∞
            updatePlayer();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤—Ä–∞–≥–∞
            updateEnemy();
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            checkCollisions();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
            updateAbilities();
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞
        function updateTimer(elapsedTime) {
            const seconds = Math.floor(elapsedTime / 1000);
            const remainingSeconds = Math.max(0, Math.floor((config.winTime - elapsedTime) / 1000));
            const minutes = Math.floor(remainingSeconds / 60);
            const secs = remainingSeconds % 60;
            elements.timer.textContent = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // –°–ø–∞–≤–Ω —Å–ª—É—á–∞–π–Ω–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
        function spawnRandomAbility() {
            if (gameState.abilities.length >= 3) return; // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π –Ω–∞ –∫–∞—Ä—Ç–µ
            
            const margin = 50;
            const width = gameState.canvasSize.width - margin * 2;
            const height = gameState.canvasSize.height - margin * 2;
            
            const abilityTypes = Object.values(AbilityType);
            const randomType = abilityTypes[Math.floor(Math.random() * abilityTypes.length)];
            
            let ability;
            let overlapping;
            
            // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –Ω–µ –ø–æ—è–≤–ª—è—é—Ç—Å—è –ø–æ–≤–µ—Ä—Ö –¥—Ä—É–≥–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
            do {
                overlapping = false;
                ability = {
                    x: margin + Math.random() * width,
                    y: margin + Math.random() * height,
                    type: randomType,
                    spawnTime: gameState.currentTime,
                    blinkPhase: 0
                };
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –∏–≥—Ä–æ–∫–æ–º
                if (checkCollision(
                    ability.x - config.playerSize/2, ability.y - config.playerSize/2, 
                    config.abilitySize + config.playerSize, config.abilitySize + config.playerSize,
                    gameState.player.x - config.playerSize/2, gameState.player.y - config.playerSize/2,
                    config.playerSize, config.playerSize
                )) {
                    overlapping = true;
                    continue;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –≤—Ä–∞–≥–æ–º
                if (checkCollision(
                    ability.x - config.enemySize/2, ability.y - config.enemySize/2, 
                    config.abilitySize + config.enemySize, config.abilitySize + config.enemySize,
                    gameState.enemy.x - config.enemySize/2, gameState.enemy.y - config.enemySize/2,
                    config.enemySize, config.enemySize
                )) {
                    overlapping = true;
                    continue;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å —è—â–∏–∫–∞–º–∏
                for (const box of gameState.boxes) {
                    if (checkCollision(
                        ability.x, ability.y, config.abilitySize, config.abilitySize,
                        box.x, box.y, box.width, box.height
                    )) {
                        overlapping = true;
                        break;
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –¥—Ä—É–≥–∏–º–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—è–º–∏
                for (const otherAbility of gameState.abilities) {
                    if (checkCollision(
                        ability.x, ability.y, config.abilitySize, config.abilitySize,
                        otherAbility.x, otherAbility.y, config.abilitySize, config.abilitySize
                    )) {
                        overlapping = true;
                        break;
                    }
                }
            } while (overlapping);
            
            gameState.abilities.push(ability);
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä–æ–∫–∞
        function updatePlayer() {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–∫–æ—Ä–µ–Ω–∏—è
            if (gameState.player.isBoosting && gameState.currentTime >= gameState.player.boostEndTime) {
                gameState.player.isBoosting = false;
                gameState.player.speed = config.playerSpeed;
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
            if (gameState.joystickActive && gameState.joystickDistance > 0.1) {
                const speed = gameState.player.speed;
                const newX = gameState.player.x + gameState.player.dx * speed;
                const newY = gameState.player.y + gameState.player.dy * speed;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏
                if (newX - config.playerSize/2 >= 0 && newX + config.playerSize/2 <= gameState.canvasSize.width) {
                    gameState.player.x = newX;
                }
                
                if (newY - config.playerSize/2 >= 0 && newY + config.playerSize/2 <= gameState.canvasSize.height) {
                    gameState.player.y = newY;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–±–æ—Ä–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
            checkAbilityPickup();
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤—Ä–∞–≥–∞
        function updateEnemy() {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–º–æ—Ä–æ–∑–∫–∏
            if (gameState.enemy.isFrozen) {
                if (gameState.currentTime >= gameState.enemy.freezeEndTime) {
                    gameState.enemy.isFrozen = false;
                } else {
                    return; // –í—Ä–∞–≥ –∑–∞–º–æ—Ä–æ–∂–µ–Ω - –Ω–µ –¥–≤–∏–≥–∞–µ—Ç—Å—è
                }
            }
            
            // –ü—Ä–æ—Å—Ç–æ–µ –ø—Ä–µ—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
            const dx = gameState.player.x - gameState.enemy.x;
            const dy = gameState.player.y - gameState.enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                const speed = config.enemySpeed;
                const vx = (dx / distance) * speed;
                const vy = (dy / distance) * speed;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å —è—â–∏–∫–∞–º–∏
                let newX = gameState.enemy.x + vx;
                let newY = gameState.enemy.y + vy;
                
                // –ü—Ä–æ—Å—Ç–æ–µ –∏–∑–±–µ–≥–∞–Ω–∏–µ —è—â–∏–∫–æ–≤ (–æ—á–µ–Ω—å —É–ø—Ä–æ—â–µ–Ω–Ω–æ–µ)
                for (const box of gameState.boxes) {
                    if (checkCollision(
                        newX - config.enemySize/2, newY - config.enemySize/2, 
                        config.enemySize, config.enemySize,
                        box.x, box.y, box.width, box.height
                    )) {
                        // –ü–æ–ø—Ä–æ–±—É–µ–º –æ–±–æ–π—Ç–∏ —è—â–∏–∫
                        if (Math.abs(dx) > Math.abs(dy)) {
                            newY = gameState.enemy.y + (dy > 0 ? speed : -speed);
                        } else {
                            newX = gameState.enemy.x + (dx > 0 ? speed : -speed);
                        }
                        break;
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü
                if (newX - config.enemySize/2 >= 0 && newX + config.enemySize/2 <= gameState.canvasSize.width) {
                    gameState.enemy.x = newX;
                }
                
                if (newY - config.enemySize/2 >= 0 && newY + config.enemySize/2 <= gameState.canvasSize.height) {
                    gameState.enemy.y = newY;
                }
            }
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–±–æ—Ä–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
        function checkAbilityPickup() {
            for (let i = gameState.abilities.length - 1; i >= 0; i--) {
                const ability = gameState.abilities[i];
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –∏–≥—Ä–æ–∫–æ–º
                if (checkCollision(
                    gameState.player.x - config.playerSize/2, gameState.player.y - config.playerSize/2, 
                    config.playerSize, config.playerSize,
                    ability.x, ability.y, config.abilitySize, config.abilitySize
                )) {
                    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å, –µ—Å–ª–∏ –µ—Å—Ç—å —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ
                    const emptySlot = gameState.playerAbilities.findIndex(slot => slot === null);
                    if (emptySlot !== -1) {
                        gameState.playerAbilities[emptySlot] = ability.type;
                        updateAbilityButton(emptySlot, ability.type);
                        gameState.abilities.splice(i, 1);
                    }
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏, –µ—Å–ª–∏ –≤—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ
                else if (gameState.currentTime - ability.spawnTime > config.abilityBlinkDuration) {
                    gameState.abilities.splice(i, 1);
                }
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
        function updateAbilityButton(index, abilityType) {
            if (abilityType) {
                elements.abilities[index].textContent = abilityType.emoji;
                elements.abilities[index].style.backgroundColor = abilityType.color;
                elements.abilities[index].classList.add("active");
            } else {
                elements.abilities[index].textContent = "‚ùå";
                elements.abilities[index].style.backgroundColor = "rgba(0, 0, 0, 0.5)";
                elements.abilities[index].classList.remove("active");
            }
        }

        // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
        function useAbility(index) {
            if (!gameState.isRunning || !gameState.playerAbilities[index]) return;
            
            const ability = gameState.playerAbilities[index];
            
            switch (ability) {
                case AbilityType.SPEED_BOOST:
                    // –£—Å–∫–æ—Ä–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
                    gameState.player.isBoosting = true;
                    gameState.player.speed = config.playerSpeed * config.playerSpeedBoost;
                    gameState.player.boostEndTime = gameState.currentTime + config.abilityDuration;
                    break;
                
                case AbilityType.DROP_BOX:
                    // –°–±—Ä–æ—Å —è—â–∏–∫–∞ –∑–∞ —Å–æ–±–æ–π
                    if (gameState.player.canDropBox) {
                        dropBoxBehindPlayer();
                        gameState.player.canDropBox = false;
                        setTimeout(() => {
                            gameState.player.canDropBox = true;
                        }, 1000);
                    } else {
                        return; // –ù–µ —Ç—Ä–∞—Ç–∏–º —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å, –µ—Å–ª–∏ –Ω–µ–ª—å–∑—è —Å–±—Ä–æ—Å–∏—Ç—å —è—â–∏–∫
                    }
                    break;
                
                case AbilityType.JUMP:
                    // –ü—Ä—ã–∂–æ–∫ —á–µ—Ä–µ–∑ –±–ª–∏–∂–∞–π—à–∏–π —è—â–∏–∫ –∏–ª–∏ —Å—Ç–µ–Ω–∫—É
                    if (gameState.player.canJump) {
                        jumpOverObstacle();
                        gameState.player.canJump = false;
                        setTimeout(() => {
                            gameState.player.canJump = true;
                        }, 1000);
                    } else {
                        return; // –ù–µ —Ç—Ä–∞—Ç–∏–º —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å, –µ—Å–ª–∏ –Ω–µ–ª—å–∑—è –ø—Ä—ã–≥–Ω—É—Ç—å
                    }
                    break;
                
                case AbilityType.FREEZE_ENEMY:
                    // –ó–∞–º–æ—Ä–æ–∑–∫–∞ –≤—Ä–∞–≥–∞
                    gameState.enemy.isFrozen = true;
                    gameState.enemy.freezeEndTime = gameState.currentTime + config.enemyFreezeDuration;
                    break;
            }
            
            // –£–¥–∞–ª–µ–Ω–∏–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
            gameState.playerAbilities[index] = null;
            updateAbilityButton(index, null);
        }

        // –°–±—Ä–æ—Å —è—â–∏–∫–∞ –∑–∞ –∏–≥—Ä–æ–∫–æ–º
        function dropBoxBehindPlayer() {
            const angle = Math.atan2(gameState.player.dy, gameState.player.dx);
            const distance = 40; // –î–∏—Å—Ç–∞–Ω—Ü–∏—è –æ—Ç –∏–≥—Ä–æ–∫–∞
            
            const boxX = gameState.player.x - Math.cos(angle) * distance - config.boxSize/2;
            const boxY = gameState.player.y - Math.sin(angle) * distance - config.boxSize/2;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ–±—ã —è—â–∏–∫ –Ω–µ –≤—ã—Ö–æ–¥–∏–ª –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã
            if (boxX >= 0 && boxX + config.boxSize <= gameState.canvasSize.width &&
                boxY >= 0 && boxY + config.boxSize <= gameState.canvasSize.height) {
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –¥—Ä—É–≥–∏–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏
                let canPlace = true;
                
                // –° –∏–≥—Ä–æ–∫–æ–º
                if (checkCollision(
                    boxX, boxY, config.boxSize, config.boxSize,
                    gameState.player.x - config.playerSize/2, gameState.player.y - config.playerSize/2,
                    config.playerSize, config.playerSize
                )) {
                    canPlace = false;
                }
                
                // –° –≤—Ä–∞–≥–æ–º
                if (checkCollision(
                    boxX, boxY, config.boxSize, config.boxSize,
                    gameState.enemy.x - config.enemySize/2, gameState.enemy.y - config.enemySize/2,
                    config.enemySize, config.enemySize
                )) {
                    canPlace = false;
                }
                
                // –° –¥—Ä—É–≥–∏–º–∏ —è—â–∏–∫–∞–º–∏
                for (const otherBox of gameState.boxes) {
                    if (checkCollision(
                        boxX, boxY, config.boxSize, config.boxSize,
                        otherBox.x, otherBox.y, otherBox.width, otherBox.height
                    )) {
                        canPlace = false;
                        break;
                    }
                }
                
                if (canPlace) {
                    gameState.boxes.push({
                        x: boxX,
                        y: boxY,
                        width: config.boxSize,
                        height: config.boxSize
                    });
                }
            }
        }

        // –ü—Ä—ã–∂–æ–∫ —á–µ—Ä–µ–∑ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ
        function jumpOverObstacle() {
            const jumpDistance = 100; // –î–∏—Å—Ç–∞–Ω—Ü–∏—è –ø—Ä—ã–∂–∫–∞
            const angle = Math.atan2(gameState.player.dy, gameState.player.dx);
            
            let newX = gameState.player.x + Math.cos(angle) * jumpDistance;
            let newY = gameState.player.y + Math.sin(angle) * jumpDistance;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü
            newX = Math.max(config.playerSize/2, Math.min(gameState.canvasSize.width - config.playerSize/2, newX));
            newY = Math.max(config.playerSize/2, Math.min(gameState.canvasSize.height - config.playerSize/2, newY));
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å —è—â–∏–∫–∞–º–∏ –Ω–∞ –ø—É—Ç–∏
            let hasObstacle = false;
            
            for (const box of gameState.boxes) {
                if (checkCollision(
                    newX - config.playerSize/2, newY - config.playerSize/2, 
                    config.playerSize, config.playerSize,
                    box.x, box.y, box.width, box.height
                )) {
                    hasObstacle = true;
                    break;
                }
            }
            
            // –ï—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ - –ø—Ä—ã–≥–∞–µ–º —á–µ—Ä–µ–∑ –Ω–µ–≥–æ (—É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –¥–∏—Å—Ç–∞–Ω—Ü–∏—é)
            if (hasObstacle) {
                newX = gameState.player.x + Math.cos(angle) * jumpDistance * 1.5;
                newY = gameState.player.y + Math.sin(angle) * jumpDistance * 1.5;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü
                newX = Math.max(config.playerSize/2, Math.min(gameState.canvasSize.width - config.playerSize/2, newX));
                newY = Math.max(config.playerSize/2, Math.min(gameState.canvasSize.height - config.playerSize/2, newY));
            }
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
            gameState.player.x = newX;
            gameState.player.y = newY;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
        function checkCollisions() {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞ —Å –≤—Ä–∞–≥–æ–º
            if (checkCollision(
                gameState.player.x - config.playerSize/2, gameState.player.y - config.playerSize/2, 
                config.playerSize, config.playerSize,
                gameState.enemy.x - config.enemySize/2, gameState.enemy.y - config.enemySize/2, 
                config.enemySize, config.enemySize
            )) {
                endGame(false);
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π –Ω–∞ –∫–∞—Ä—Ç–µ
        function updateAbilities() {
            for (const ability of gameState.abilities) {
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∞–∑—ã –º–∏–≥–∞–Ω–∏—è (0-1)
                const timeSinceSpawn = gameState.currentTime - ability.spawnTime;
                ability.blinkPhase = 1 - Math.min(1, timeSinceSpawn / config.abilityBlinkDuration);
            }
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è –¥–≤—É—Ö –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤
        function checkCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 < x2 + w2 && 
                   x1 + w1 > x2 && 
                   y1 < y2 + h2 && 
                   y1 + h1 > y2;
        }

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–≥—Ä—ã
        function renderGame() {
            const ctx = elements.ctx;
            const width = gameState.canvasSize.width;
            const height = gameState.canvasSize.height;
            
            // –û—á–∏—Å—Ç–∫–∞ canvas
            ctx.clearRect(0, 0, width, height);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ñ–æ–Ω–∞
            ctx.fillStyle = "#333";
            ctx.fillRect(0, 0, width, height);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —è—â–∏–∫–æ–≤
            ctx.fillStyle = "#8B4513"; // –ö–æ—Ä–∏—á–Ω–µ–≤—ã–π
            for (const box of gameState.boxes) {
                ctx.fillRect(box.x, box.y, box.width, box.height);
                ctx.strokeStyle = "#000";
                ctx.strokeRect(box.x, box.y, box.width, box.height);
            }
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
            for (const ability of gameState.abilities) {
                const size = config.abilitySize;
                const halfSize = size / 2;
                
                // –ú–∏–≥–∞–Ω–∏–µ (–∏–∑–º–µ–Ω–µ–Ω–∏–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏)
                const alpha = 0.7 + 0.3 * Math.sin(ability.blinkPhase * Math.PI * 10);
                ctx.globalAlpha = alpha;
                
                // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
                ctx.fillStyle = ability.type.color;
                ctx.beginPath();
                ctx.arc(ability.x + halfSize, ability.y + halfSize, halfSize, 0, Math.PI * 2);
                ctx.fill();
                
                // –¢–µ–∫—Å—Ç (—ç–º–æ–¥–∑–∏)
                ctx.fillStyle = "#000";
                ctx.font = `${halfSize}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(ability.type.emoji, ability.x + halfSize, ability.y + halfSize);
                
                ctx.globalAlpha = 1;
            }
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≤—Ä–∞–≥–∞
            ctx.fillStyle = gameState.enemy.isFrozen ? "#ADD8E6" : "#FF0000"; // –°–∏–Ω–∏–π –µ—Å–ª–∏ –∑–∞–º–æ—Ä–æ–∂–µ–Ω, –∏–Ω–∞—á–µ –∫—Ä–∞—Å–Ω—ã–π
            ctx.beginPath();
            ctx.arc(gameState.enemy.x, gameState.enemy.y, config.enemySize/2, 0, Math.PI * 2);
            ctx.fill();
            
            // –ì–ª–∞–∑–∞ –≤—Ä–∞–≥–∞ (—á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –∫ –∏–≥—Ä–æ–∫—É)
            const angleToPlayer = Math.atan2(
                gameState.player.y - gameState.enemy.y, 
                gameState.player.x - gameState.enemy.x
            );
            
            const eyeOffsetX = Math.cos(angleToPlayer) * 5;
            const eyeOffsetY = Math.sin(angleToPlayer) * 5;
            
            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.arc(
                gameState.enemy.x + eyeOffsetX - 3, 
                gameState.enemy.y + eyeOffsetY - 3, 
                3, 0, Math.PI * 2
            );
            ctx.arc(
                gameState.enemy.x + eyeOffsetX + 3, 
                gameState.enemy.y + eyeOffsetY - 3, 
                3, 0, Math.PI * 2
            );
            ctx.fill();
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–≥—Ä–æ–∫–∞
            ctx.fillStyle = gameState.player.isBoosting ? "#FFFF00" : "#00FF00"; // –ñ–µ–ª—Ç—ã–π –µ—Å–ª–∏ —É—Å–∫–æ—Ä–µ–Ω–∏–µ, –∏–Ω–∞—á–µ –∑–µ–ª–µ–Ω—ã–π
            ctx.beginPath();
            ctx.arc(gameState.player.x, gameState.player.y, config.playerSize/2, 0, Math.PI * 2);
            ctx.fill();
            
            // –ì–ª–∞–∑–∞ –∏–≥—Ä–æ–∫–∞ (–ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è)
            if (gameState.joystickDistance > 0.1) {
                const eyeOffsetX = Math.cos(gameState.joystickAngle) * 5;
                const eyeOffsetY = Math.sin(gameState.joystickAngle) * 5;
                
                ctx.fillStyle = "#FFF";
                ctx.beginPath();
                ctx.arc(
                    gameState.player.x + eyeOffsetX - 3, 
                    gameState.player.y + eyeOffsetY - 3, 
                    3, 0, Math.PI * 2
                );
                ctx.arc(
                    gameState.player.x + eyeOffsetX + 3, 
                    gameState.player.y + eyeOffsetY - 3, 
                    3, 0, Math.PI * 2
                );
                ctx.fill();
            }
        }

        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏–≥—Ä—ã
        function endGame(isWin) {
            gameState.isRunning = false;
            
            const elapsedTime = gameState.currentTime - gameState.startTime;
            const seconds = (elapsedTime / 1000).toFixed(1);
            
            elements.resultText.textContent = isWin ? "–ü–æ–±–µ–¥–∞!" : "–ü–æ—Ä–∞–∂–µ–Ω–∏–µ!";
            elements.timeSurvived.textContent = `–í—ã –ø—Ä–æ–¥–µ—Ä–∂–∞–ª–∏—Å—å: ${seconds} —Å–µ–∫`;
            
            elements.resultScreen.style.display = "flex";
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener("load", initGame);
    </script>
</body>
</html>
