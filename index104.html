<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG Dungeon Simulator deepseek</title>
    <style>
        :root {
            --dark-bg: #0a0a12;
            --darker-bg: #050508;
            --panel-bg: #151522;
            --accent: #2a5a8a;
            --accent-light: #3a7aba;
            --text: #e0e0e0;
            --text-dim: #a0a0a0;
            --hp-color: #c53a3a;
            --mp-color: #3a5ac5;
            --tank-color: #8B4513;
            --healer-color: #2a8a2a;
            --support-color: #7a3a8a;
            --mage-color: #ba3a3a;
            --enemy-color: #8a2a2a;
            --boss-color: #8a5a2a;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: var(--dark-bg);
            color: var(--text);
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
        }
        
        h1, h2, h3 {
            color: var(--text);
            font-weight: 600;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.8em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .screen {
            display: none;
        }
        
        .active {
            display: block;
        }
        
        /* –û—Å–Ω–æ–≤–Ω–æ–π –∏–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω */
        .game-container {
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 15px;
            height: 95vh;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 12px 15px;
            border: 1px solid #2a2a3a;
        }
        
        .dungeon-info {
            font-size: 1.1em;
            font-weight: 500;
        }
        
        .currency {
            font-size: 1.2em;
            color: var(--accent-light);
            font-weight: 600;
        }
        
        .battle-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            height: 100%;
        }
        
        .party-side, .enemy-side {
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            border: 1px solid #2a2a3a;
        }
        
        .side-title {
            text-align: center;
            margin-bottom: 15px;
            color: var(--text);
            font-size: 1.2em;
            font-weight: 600;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a2a3a;
        }
        
        .party-member, .enemy {
            background: var(--darker-bg);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            position: relative;
            border: 1px solid #2a2a3a;
            height: 180px;
            display: flex;
            flex-direction: column;
        }
        
        .member-header, .enemy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .member-name, .enemy-name {
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .member-role, .enemy-type {
            font-size: 0.85em;
            color: var(--text-dim);
        }
        
        .health-bar, .mana-bar, .enemy-health {
            height: 16px;
            border-radius: 3px;
            background: #1a1a2a;
            margin-bottom: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(to right, var(--hp-color), #e05a5a);
            transition: width 0.3s;
        }
        
        .mana-fill {
            height: 100%;
            background: linear-gradient(to right, var(--mp-color), #5a7ae0);
            transition: width 0.3s;
        }
        
        .health-text, .mana-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 10px;
            line-height: 16px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            font-weight: 600;
        }
        
        .member-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            gap: 5px;
        }
        
        .member-action {
            flex: 1;
            background: #2a2a3a;
            border: none;
            border-radius: 4px;
            color: var(--text);
            padding: 6px 4px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 50px;
        }
        
        .member-action:hover:not(:disabled) {
            background: #3a3a4a;
        }
        
        .member-action:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .action-icon {
            font-size: 14px;
            margin-bottom: 3px;
        }
        
        .action-name {
            font-size: 9px;
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .action-details {
            font-size: 8px;
            color: var(--text-dim);
        }
        
        .abilities {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
        }
        
        .ability {
            width: 22px;
            height: 22px;
            border-radius: 3px;
            background: #2a2a3a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            position: relative;
            overflow: hidden;
            border: 1px solid #3a3a4a;
        }
        
        .ability.ready {
            background: #3a3a5a;
        }
        
        .ability.on-cooldown {
            background: #1a1a2a;
        }
        
        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
        }
        
        .player-abilities {
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            border: 1px solid #2a2a3a;
        }
        
        .player-ability {
            background: #2a2a3a;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #3a3a4a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 90px;
            position: relative;
        }
        
        .player-ability:hover:not(.on-cooldown) {
            background: #3a3a5a;
            border-color: var(--accent);
        }
        
        .player-ability.on-cooldown {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .ability-icon {
            font-size: 20px;
            margin-bottom: 5px;
        }
        
        .ability-name {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 3px;
        }
        
        .ability-details {
            font-size: 9px;
            color: var(--text-dim);
        }
        
        .player-cooldown {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            border-radius: 6px;
        }
        
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }
        
        button {
            background: var(--accent);
            border: none;
            border-radius: 5px;
            color: white;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: var(--accent-light);
        }
        
        button:disabled {
            background: #3a3a4a;
            cursor: not-allowed;
        }
        
        /* –≠–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–∏ */
        .role-selection {
            text-align: center;
        }
        
        .roles {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 25px 0;
        }
        
        .role-card {
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid #2a2a3a;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .role-card:hover {
            border-color: var(--accent);
            transform: translateY(-5px);
        }
        
        .role-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        
        .role-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text);
        }
        
        .role-desc {
            font-size: 13px;
            color: var(--text-dim);
            text-align: center;
        }
        
        /* –≠–∫—Ä–∞–Ω –º–∞–≥–∞–∑–∏–Ω–∞ */
        .shop {
            text-align: center;
        }
        
        .upgrades {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 25px 0;
        }
        
        .upgrade {
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid #2a2a3a;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .upgrade:hover {
            border-color: var(--accent);
        }
        
        .upgrade-icon {
            font-size: 30px;
            margin-bottom: 10px;
        }
        
        .upgrade-name {
            font-size: 16px;
            margin-bottom: 10px;
            color: var(--text);
            font-weight: 600;
        }
        
        .upgrade-desc {
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 10px;
            text-align: center;
        }
        
        .upgrade-cost {
            font-size: 14px;
            color: var(--accent-light);
            font-weight: 600;
        }
        
        .upgrade-level {
            font-size: 12px;
            color: var(--text);
            margin-top: 5px;
        }
        
        /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç–∏ –±–æ—Å—Å–∞ */
        .invulnerable {
            position: relative;
            overflow: hidden;
        }
        
        .invulnerable::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.3; }
            50% { opacity: 0.6; }
            100% { opacity: 0.3; }
        }
        
        /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –±–∞—Ñ—Ñ–æ–≤ */
        .buffs {
            display: flex;
            gap: 5px;
            margin-top: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .buff {
            width: 18px;
            height: 18px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            position: relative;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .buff.shield {
            background: rgba(255, 215, 0, 0.2);
        }
        
        .buff.barrier {
            background: rgba(30, 144, 255, 0.2);
        }
        
        .buff.regen {
            background: rgba(50, 205, 50, 0.2);
        }
        
        .buff.attack {
            background: rgba(220, 20, 60, 0.2);
        }
        
        .buff.defense {
            background: rgba(139, 69, 19, 0.2);
        }
        
        .buff.dodge {
            background: rgba(147, 112, 219, 0.2);
        }
        
        .buff-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 20, 0.9);
            color: white;
            padding: 5px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            display: none;
            z-index: 10;
            border: 1px solid #2a2a3a;
        }
        
        .buff:hover .buff-tooltip {
            display: block;
        }
        
        /* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å */
        @media (max-width: 768px) {
            .battle-area {
                grid-template-columns: 1fr;
            }
            
            .player-abilities {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .roles, .upgrades {
                grid-template-columns: 1fr;
            }
        }
        
        /* –°—Ç–∞—Ç—É—Å—ã */
        .status-effects {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 5px;
            justify-content: center;
        }
        
        .status-effect {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .status-hot {
            background: rgba(50, 205, 50, 0.2);
        }
        
        .status-dot {
            background: rgba(220, 20, 60, 0.2);
        }
        
        .dead-member {
            opacity: 0.6;
            background: rgba(50, 50, 50, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RPG Dungeon Simulator</h1>
        
        <!-- –≠–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–∏ -->
        <div id="roleSelection" class="screen active">
            <div class="role-selection">
                <h2>–í—ã–±–µ—Ä–∏—Ç–µ —Å–≤–æ—é —Ä–æ–ª—å</h2>
                <p>–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å, –∫–æ—Ç–æ—Ä—É—é –±—É–¥–µ—Ç–µ –∏–≥—Ä–∞—Ç—å. –û—Å—Ç–∞–ª—å–Ω—ã–µ —á–ª–µ–Ω—ã –≥—Ä—É–ø–ø—ã –±—É–¥—É—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å—Å—è –ò–ò.</p>
                
                <div class="roles">
                    <div class="role-card" data-role="tank">
                        <div class="role-icon">üõ°Ô∏è</div>
                        <div class="role-name">–¢–∞–Ω–∫</div>
                        <div class="role-desc">–£–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –∞–≥–≥—Ä–æ –≤—Ä–∞–≥–æ–≤, –∑–∞—â–∏—â–∞–π—Ç–µ —Å–æ—é–∑–Ω–∏–∫–æ–≤</div>
                    </div>
                    
                    <div class="role-card" data-role="healer">
                        <div class="role-icon">‚ù§Ô∏è</div>
                        <div class="role-name">–•–∏–ª–µ—Ä</div>
                        <div class="role-desc">–õ–µ—á–∏—Ç–µ —Å–æ—é–∑–Ω–∏–∫–æ–≤, –≤–æ—Å–∫—Ä–µ—à–∞–π—Ç–µ –ø–∞–≤—à–∏—Ö</div>
                    </div>
                    
                    <div class="role-card" data-role="support">
                        <div class="role-icon">‚ú®</div>
                        <div class="role-name">–°–∞–ø–ø–æ—Ä—Ç</div>
                        <div class="role-desc">–ë–∞—Ñ—Ñ–∞–π—Ç–µ –≥—Ä—É–ø–ø—É, –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–π—Ç–µ –º–∞–Ω—É</div>
                    </div>
                    
                    <div class="role-card" data-role="mage">
                        <div class="role-icon">üî•</div>
                        <div class="role-name">–ú–∞–≥</div>
                        <div class="role-desc">–ù–∞–Ω–æ—Å–∏—Ç–µ –º–∞–≥–∏—á–µ—Å–∫–∏–π —É—Ä–æ–Ω, –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–π—Ç–µ –≤—Ä–∞–≥–æ–≤</div>
                    </div>
                </div>
                
                <button id="startGame">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
            </div>
        </div>
        
        <!-- –û—Å–Ω–æ–≤–Ω–æ–π –∏–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω -->
        <div id="gameScreen" class="screen">
            <div class="game-container">
                <div class="header">
                    <div class="dungeon-info">
                        <span id="currentDungeon">–õ–µ—Å –¢–µ–Ω–µ–π</span> | –í–æ–ª–Ω–∞: <span id="currentWave">1</span>/3
                    </div>
                    <div class="currency">
                        –ó–æ–ª–æ—Ç–æ: <span id="currencyAmount">50</span>
                    </div>
                </div>
                
                <div class="battle-area">
                    <div class="party-side">
                        <div class="side-title">–í–∞—à–∞ –≥—Ä—É–ø–ø–∞</div>
                        <div id="partyDisplay">
                            <!-- –ß–ª–µ–Ω—ã –≥—Ä—É–ø–ø—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
                        </div>
                    </div>
                    
                    <div class="enemy-side">
                        <div class="side-title">–í—Ä–∞–≥–∏</div>
                        <div id="enemiesDisplay">
                            <!-- –í—Ä–∞–≥–∏ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
                        </div>
                    </div>
                </div>
                
                <div class="player-abilities" id="playerAbilities">
                    <!-- –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –∏–≥—Ä–æ–∫–∞ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
                </div>
                
                <div class="action-buttons">
                    <button id="nextDungeon" disabled>–°–ª–µ–¥—É—é—â–∏–π –¥–∞–Ω–∂</button>
                    <button id="openShop">–ú–∞–≥–∞–∑–∏–Ω —É–ª—É—á—à–µ–Ω–∏–π</button>
                </div>
            </div>
        </div>
        
        <!-- –≠–∫—Ä–∞–Ω –º–∞–≥–∞–∑–∏–Ω–∞ -->
        <div id="shopScreen" class="screen">
            <div class="shop">
                <h2>–ú–∞–≥–∞–∑–∏–Ω —É–ª—É—á—à–µ–Ω–∏–π</h2>
                <div class="currency">–í–∞—à–∏ –∑–æ–ª–æ—Ç—ã–µ: <span id="shopCurrencyAmount">50</span></div>
                
                <div class="upgrades" id="upgrades">
                    <!-- –£–ª—É—á—à–µ–Ω–∏—è –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
                </div>
                
                <div class="action-buttons">
                    <button id="backToGame">–í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –∏–≥—Ä–µ</button>
                </div>
            </div>
        </div>
        
        <!-- –≠–∫—Ä–∞–Ω –ø–æ—Ä–∞–∂–µ–Ω–∏—è -->
        <div id="gameOverScreen" class="screen">
            <div style="text-align: center;">
                <h2>–ü–æ—Ä–∞–∂–µ–Ω–∏–µ!</h2>
                <p>–í–∞—à–∞ –≥—Ä—É–ø–ø–∞ –ø–∞–ª–∞ –≤ –±–æ—é.</p>
                <p>–í—ã –ø—Ä–æ—à–ª–∏ <span id="dungeonsCompleted">0</span> –¥–∞–Ω–∂–µ–π</p>
                <button id="restartGame">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
            </div>
        </div>
    </div>

    <script>
        // –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–≥—Ä—ã
        const ROLES = {
            TANK: 'tank',
            HEALER: 'healer',
            SUPPORT: 'support',
            MAGE: 'mage'
        };

        const DUNGEONS = [
            { name: "–õ–µ—Å –¢–µ–Ω–µ–π", waves: 3, enemiesPerWave: 3, reward: 20, boss: false },
            { name: "–ü–µ—â–µ—Ä—ã –ì–æ–±–ª–∏–Ω–æ–≤", waves: 4, enemiesPerWave: 4, reward: 30, boss: false },
            { name: "–ó–∞–º–æ–∫ –ù–µ–∂–∏—Ç–∏", waves: 3, enemiesPerWave: 5, reward: 40, boss: true },
            { name: "–õ–æ–≥–æ–≤–æ –î—Ä–∞–∫–æ–Ω–∞", waves: 4, enemiesPerWave: 6, reward: 50, boss: true }
        ];

        let gameState = {
            playerRole: null,
            party: {},
            enemies: [],
            currentDungeon: 0,
            currentWave: 0,
            currency: 50,
            gameActive: false,
            abilityCooldowns: {},
            playerAbilities: [],
            upgrades: {},
            gameLoopInterval: null,
            bossInvulnerable: false,
            bossInvulnerableTimer: 0,
            dungeonMultiplier: 1,
            activeBuffs: {},
            buffTimers: {},
            statusEffects: {},
            tickCounter: 0
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        document.addEventListener('DOMContentLoaded', function() {
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–∏
            const roleCards = document.querySelectorAll('.role-card');
            roleCards.forEach(card => {
                card.addEventListener('click', function() {
                    roleCards.forEach(c => c.style.borderColor = '#2a2a3a');
                    this.style.borderColor = 'var(--accent)';
                    gameState.playerRole = this.getAttribute('data-role');
                });
            });

            // –ö–Ω–æ–ø–∫–∞ –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã
            document.getElementById('startGame').addEventListener('click', function() {
                if (!gameState.playerRole) {
                    alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å!');
                    return;
                }
                startGame();
            });

            // –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
            document.getElementById('nextDungeon').addEventListener('click', nextDungeon);
            document.getElementById('openShop').addEventListener('click', openShop);
            document.getElementById('backToGame').addEventListener('click', backToGame);
            document.getElementById('restartGame').addEventListener('click', restartGame);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–ª—É—á—à–µ–Ω–∏–π
            initUpgrades();
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–ª—É—á—à–µ–Ω–∏–π
        function initUpgrades() {
            gameState.upgrades = {
                health: { level: 0, cost: 100, effect: 0.1, maxLevel: 999, description: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ –≥—Ä—É–ø–ø—ã –Ω–∞ 10%" },
                mana: { level: 0, cost: 100, effect: 0.1, maxLevel: 999, description: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –º–∞–Ω—É –≥—Ä—É–ø–ø—ã –Ω–∞ 10%" },
                damage: { level: 0, cost: 150, effect: 0.06, maxLevel: 999, description: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —É—Ä–æ–Ω –Ω–∞ 6%" },
                healing: { level: 0, cost: 150, effect: 0.1, maxLevel: 5, description: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –ª–µ—á–µ–Ω–∏–µ –Ω–∞ 10%" },
                cooldown: { level: 0, cost: 200, effect: 0.06, maxLevel: 5, description: "–£–º–µ–Ω—å—à–∞–µ—Ç –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫—É –Ω–∞ 6%" },
                manaCost: { level: 0, cost: 200, effect: 0.06, maxLevel: 5, description: "–£–º–µ–Ω—å—à–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å –º–∞–Ω—ã –Ω–∞ 6%" }
            };
        }

        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        function startGame() {
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä—É–ø–ø—ã
            initParty();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π –∏–≥—Ä–æ–∫–∞
            initPlayerAbilities();
            
            // –ù–∞—á–∞–ª–æ –ø–µ—Ä–≤–æ–≥–æ –¥–∞–Ω–∂–∞
            startDungeon(0);
            
            // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–æ–≤
            switchScreen('gameScreen');
            
            // –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
            gameState.gameActive = true;
            gameState.gameLoopInterval = setInterval(gameLoop, 1000); // 1 —Å–µ–∫—É–Ω–¥–∞ = 1 –∏—Ç–µ—Ä–∞—Ü–∏—è
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä—É–ø–ø—ã
        function initParty() {
            // –ë–∞–∑–æ–≤—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
            const baseStats = {
                tank: { health: 600, mana: 100, damage: 20 },
                healer: { health: 300, mana: 200, damage: 10 },
                support: { health: 250, mana: 300, damage: 10 },
                mage: { health: 200, mana: 250, damage: 30 }
            };
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —É–ª—É—á—à–µ–Ω–∏—è
            const healthMultiplier = 1 + (gameState.upgrades.health.level * gameState.upgrades.health.effect);
            const manaMultiplier = 1 + (gameState.upgrades.mana.level * gameState.upgrades.mana.effect);
            const damageMultiplier = 1 + (gameState.upgrades.damage.level * gameState.upgrades.damage.effect);
            
            gameState.party = {
                tank: { 
                    name: '–¢–∞–Ω–∫', 
                    health: Math.floor(baseStats.tank.health * healthMultiplier), 
                    maxHealth: Math.floor(baseStats.tank.health * healthMultiplier), 
                    mana: Math.floor(baseStats.tank.mana * manaMultiplier), 
                    maxMana: Math.floor(baseStats.tank.mana * manaMultiplier), 
                    damage: Math.floor(baseStats.tank.damage * damageMultiplier),
                    role: ROLES.TANK,
                    alive: true,
                    abilities: [
                        { id: 'taunt', name: '–ü—Ä–æ–≤–æ–∫–∞—Ü–∏—è', icon: 'üó£Ô∏è', cost: 20, cooldown: 10, currentCooldown: 0, description: "–í—Å–µ –≤—Ä–∞–≥–∏ –∞—Ç–∞–∫—É—é—Ç —Ç–∞–Ω–∫–∞" },
                        { id: 'shield', name: '–©–∏—Ç', icon: 'üõ°Ô∏è', cost: 30, cooldown: 15, currentCooldown: 0, description: "+50% –∑–∞—â–∏—Ç—ã –Ω–∞ 8 —Å–µ–∫" },
                        { id: 'strike', name: '–£–¥–∞—Ä', icon: '‚öîÔ∏è', cost: 10, cooldown: 3, currentCooldown: 0, description: "–ù–∞–Ω–æ—Å–∏—Ç 40 —É—Ä–æ–Ω–∞" },
                        { id: 'challenge', name: '–í—ã–∑–æ–≤', icon: 'üëä', cost: 40, cooldown: 20, currentCooldown: 0, description: "–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç 100 –∑–¥–æ—Ä–æ–≤—å—è" }
                    ]
                },
                healer: { 
                    name: '–•–∏–ª–µ—Ä', 
                    health: Math.floor(baseStats.healer.health * healthMultiplier), 
                    maxHealth: Math.floor(baseStats.healer.health * healthMultiplier), 
                    mana: Math.floor(baseStats.healer.mana * manaMultiplier), 
                    maxMana: Math.floor(baseStats.healer.mana * manaMultiplier), 
                    damage: Math.floor(baseStats.healer.damage * damageMultiplier),
                    role: ROLES.HEALER,
                    alive: true,
                    abilities: [
                        { id: 'heal', name: '–õ–µ—á–µ–Ω–∏–µ', icon: '‚ù§Ô∏è', cost: 25, cooldown: 1, currentCooldown: 0, description: "–õ–µ—á–∏—Ç 60 HP —Å–æ—é–∑–Ω–∏–∫—É" },
                        { id: 'groupHeal', name: '–ì—Ä—É–ø.–ª–µ—á–µ–Ω–∏–µ', icon: 'üíñ', cost: 50, cooldown: 8, currentCooldown: 0, description: "–õ–µ—á–∏—Ç 40 HP –≤—Å–µ–π –≥—Ä—É–ø–ø–µ" },
                        { id: 'resurrect', name: '–í–æ—Å–∫—Ä–µ—à–µ–Ω–∏–µ', icon: '‚≠ê', cost: 100, cooldown: 30, currentCooldown: 0, description: "–í–æ—Å–∫—Ä–µ—à–∞–µ—Ç —Å–æ—é–∑–Ω–∏–∫–∞" },
                        { id: 'barrier', name: '–ë–∞—Ä—å–µ—Ä', icon: 'üî∞', cost: 60, cooldown: 20, currentCooldown: 0, description: "–ü–æ–ª–Ω–∞—è –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å –Ω–∞ 4 —Å–µ–∫" }
                    ]
                },
                support: { 
                    name: '–°–∞–ø–ø–æ—Ä—Ç', 
                    health: Math.floor(baseStats.support.health * healthMultiplier), 
                    maxHealth: Math.floor(baseStats.support.health * healthMultiplier), 
                    mana: Math.floor(baseStats.support.mana * manaMultiplier), 
                    maxMana: Math.floor(baseStats.support.mana * manaMultiplier), 
                    damage: Math.floor(baseStats.support.damage * damageMultiplier),
                    role: ROLES.SUPPORT,
                    alive: true,
                    abilities: [
                        { id: 'groupBuff', name: '–ì—Ä—É–ø.–±–∞—Ñ—Ñ', icon: 'üìà', cost: 60, cooldown: 28, currentCooldown: 0, description: "+30% –∫ –∞—Ç–∞–∫–µ –∏ –∑–∞—â–∏—Ç–µ –Ω–∞ 30 —Å–µ–∫" },
                        { id: 'manaRegen', name: '–í–æ—Å—Å—Ç.–º–∞–Ω—ã', icon: 'üîã', cost: 40, cooldown: 15, currentCooldown: 0, description: "–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç 25% –º–∞–Ω—ã –≥—Ä—É–ø–ø–µ" },
                        { id: 'singleMana', name: '–¢–æ—á.–º–∞–Ω–∞', icon: '‚ú®', cost: 30, cooldown: 10, currentCooldown: 0, description: "–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç 50% –º–∞–Ω—ã —Å–æ—é–∑–Ω–∏–∫—É" },
                        { id: 'groupShield', name: '–ì—Ä—É–ø.—â–∏—Ç', icon: 'üõ°Ô∏è', cost: 80, cooldown: 30, currentCooldown: 0, description: "–ü–æ–≥–ª–æ—â–∞–µ—Ç –≤–µ—Å—å —É—Ä–æ–Ω –Ω–∞ 6 —Å–µ–∫" }
                    ]
                },
                mage: { 
                    name: '–ú–∞–≥', 
                    health: Math.floor(baseStats.mage.health * healthMultiplier), 
                    maxHealth: Math.floor(baseStats.mage.health * healthMultiplier), 
                    mana: Math.floor(baseStats.mage.mana * manaMultiplier), 
                    maxMana: Math.floor(baseStats.mage.mana * manaMultiplier), 
                    damage: Math.floor(baseStats.mage.damage * damageMultiplier),
                    role: ROLES.MAGE,
                    alive: true,
                    abilities: [
                        { id: 'fireball', name: '–û–≥–Ω–µ–Ω–Ω—ã–π —à–∞—Ä', icon: 'üî•', cost: 30, cooldown: 4, currentCooldown: 0, description: "15% —É—Ä–æ–Ω–∞ –æ—Ç –•–ü –≤—Ä–∞–≥–∞ (3% –¥–ª—è –±–æ—Å—Å–∞)" },
                        { id: 'frostbolt', name: '–õ–µ–¥—è–Ω–∞—è —Å—Ç—Ä–µ–ª–∞', icon: '‚ùÑÔ∏è', cost: 40, cooldown: 6, currentCooldown: 0, description: "20% —É—Ä–æ–Ω–∞ –æ—Ç –•–ü –≤—Ä–∞–≥–∞ (4% –¥–ª—è –±–æ—Å—Å–∞)" },
                        { id: 'lightning', name: '–ú–æ–ª–Ω–∏—è', icon: '‚ö°', cost: 50, cooldown: 8, currentCooldown: 0, description: "25% —É—Ä–æ–Ω–∞ –æ—Ç –•–ü –≤—Ä–∞–≥–∞ (5% –¥–ª—è –±–æ—Å—Å–∞)" },
                        { id: 'meteor', name: '–ú–µ—Ç–µ–æ—Ä–∏—Ç', icon: 'üí´', cost: 80, cooldown: 20, currentCooldown: 0, description: "40% —É—Ä–æ–Ω–∞ –æ—Ç –•–ü –≤—Ä–∞–≥–∞ (8% –¥–ª—è –±–æ—Å—Å–∞)" }
                    ]
                }
            };
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –±–∞—Ñ—Ñ–æ–≤
            gameState.activeBuffs = {
                tank: [],
                healer: [],
                support: [],
                mage: []
            };
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∞–π–º–µ—Ä–æ–≤ –±–∞—Ñ—Ñ–æ–≤
            gameState.buffTimers = {};
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–∞—Ç—É—Å —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
            gameState.statusEffects = {
                tank: [],
                healer: [],
                support: [],
                mage: []
            };
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –≥—Ä—É–ø–ø—ã
            updatePartyUI();
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π –∏–≥—Ä–æ–∫–∞
        function initPlayerAbilities() {
            const abilitiesContainer = document.getElementById('playerAbilities');
            abilitiesContainer.innerHTML = '';
            
            const player = gameState.party[gameState.playerRole];
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —É–ª—É—á—à–µ–Ω–∏—è –∫ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—è–º
            const cooldownMultiplier = 1 - (gameState.upgrades.cooldown.level * gameState.upgrades.cooldown.effect);
            const manaCostMultiplier = 1 - (gameState.upgrades.manaCost.level * gameState.upgrades.manaCost.effect);
            const healingMultiplier = 1 + (gameState.upgrades.healing.level * gameState.upgrades.healing.effect);
            const damageMultiplier = 1 + (gameState.upgrades.damage.level * gameState.upgrades.damage.effect);
            
            player.abilities.forEach(ability => {
                const abilityElement = document.createElement('div');
                abilityElement.className = 'player-ability';
                abilityElement.setAttribute('data-ability', ability.id);
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º —É–ª—É—á—à–µ–Ω–∏—è
                const actualCooldown = Math.max(1, Math.floor(ability.cooldown * cooldownMultiplier));
                const actualCost = Math.max(1, Math.floor(ability.cost * manaCostMultiplier));
                
                // –ü–æ–ª—É—á–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
                let description = ability.description;
                
                abilityElement.innerHTML = `
                    <div class="ability-icon">${ability.icon}</div>
                    <div class="ability-name">${ability.name}</div>
                    <div class="ability-details">${actualCost} MP | ${actualCooldown}—Å</div>
                    <div class="ability-details">${description}</div>
                `;
                
                abilityElement.addEventListener('click', function() {
                    usePlayerAbility(ability.id);
                });
                
                abilitiesContainer.appendChild(abilityElement);
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫—É–ª–¥–∞—É–Ω
                gameState.abilityCooldowns[ability.id] = 0;
            });
        }

        // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –∏–≥—Ä–æ–∫–æ–º
        function usePlayerAbility(abilityId) {
            const player = gameState.party[gameState.playerRole];
            const ability = player.abilities.find(a => a.id === abilityId);
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—É–ª–¥–∞—É–Ω
            if (gameState.abilityCooldowns[abilityId] > 0) {
                return;
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞–Ω—É
            const manaCostMultiplier = 1 - (gameState.upgrades.manaCost.level * gameState.upgrades.manaCost.effect);
            const actualCost = Math.max(1, Math.floor(ability.cost * manaCostMultiplier));
            
            if (player.mana < actualCost) {
                return;
            }
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∞–Ω—É
            player.mana -= actualCost;
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫—É–ª–¥–∞—É–Ω
            const cooldownMultiplier = 1 - (gameState.upgrades.cooldown.level * gameState.upgrades.cooldown.effect);
            const actualCooldown = Math.max(1, Math.floor(ability.cooldown * cooldownMultiplier));
            gameState.abilityCooldowns[abilityId] = actualCooldown;
            
            // –≠—Ñ—Ñ–µ–∫—Ç—ã —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
            executePlayerAbility(abilityId);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
            updatePartyUI();
            updatePlayerAbilitiesUI();
        }

        // –í—ã–ø–æ–ª–Ω–∏—Ç—å —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –∏–≥—Ä–æ–∫–∞
        function executePlayerAbility(abilityId) {
            const player = gameState.party[gameState.playerRole];
            const healingMultiplier = 1 + (gameState.upgrades.healing.level * gameState.upgrades.healing.effect);
            const damageMultiplier = 1 + (gameState.upgrades.damage.level * gameState.upgrades.damage.effect);
            
            switch(abilityId) {
                case 'taunt':
                    gameState.enemies.forEach(enemy => {
                        enemy.target = 'tank';
                    });
                    break;
                    
                case 'shield':
                    addBuff(player.role, 'shield', 8);
                    break;
                    
                case 'heal':
                    // –õ–µ—á–∏–º —Å–∞–º–æ–≥–æ —Ä–∞–Ω–µ–Ω–æ–≥–æ —Å–æ—é–∑–Ω–∏–∫–∞
                    let lowestHealth = 100;
                    let healTarget = null;
                    
                    for (const role in gameState.party) {
                        const member = gameState.party[role];
                        if (member.alive && member.health < member.maxHealth) {
                            const healthPercent = member.health / member.maxHealth;
                            if (healthPercent < lowestHealth) {
                                lowestHealth = healthPercent;
                                healTarget = role;
                            }
                        }
                    }
                    
                    if (healTarget) {
                        const healAmount = Math.floor(60 * healingMultiplier);
                        gameState.party[healTarget].health = Math.min(
                            gameState.party[healTarget].maxHealth, 
                            gameState.party[healTarget].health + healAmount
                        );
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –•–û–¢ —ç—Ñ—Ñ–µ–∫—Ç
                        addStatusEffect(healTarget, 'hot', 3, { 
                            ticks: 3, 
                            healPerTick: Math.floor(healTarget.maxHealth * 0.02) + 40,
                            currentTick: 0 
                        });
                    }
                    break;
                    
                case 'groupHeal':
                    const groupHealAmount = Math.floor(40 * healingMultiplier);
                    for (const role in gameState.party) {
                        if (gameState.party[role].alive) {
                            gameState.party[role].health = Math.min(
                                gameState.party[role].maxHealth, 
                                gameState.party[role].health + groupHealAmount
                            );
                        }
                    }
                    break;
                    
                case 'resurrect':
                    // –í–æ—Å–∫—Ä–µ—à–∞–µ–º –ø–µ—Ä–≤–æ–≥–æ –º–µ—Ä—Ç–≤–æ–≥–æ —Å–æ—é–∑–Ω–∏–∫–∞
                    for (const role in gameState.party) {
                        if (!gameState.party[role].alive) {
                            gameState.party[role].alive = true;
                            gameState.party[role].health = gameState.party[role].maxHealth * 0.3;
                            gameState.party[role].mana = gameState.party[role].maxMana * 0.5;
                            break;
                        }
                    }
                    break;
                    
                case 'barrier':
                    // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–Ω—É—é –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å —Å–∞–º–æ–º—É —Ä–∞–Ω–µ–Ω–æ–º—É —Å–æ—é–∑–Ω–∏–∫—É
                    let mostWounded = 100;
                    let barrierTarget = null;
                    
                    for (const role in gameState.party) {
                        const member = gameState.party[role];
                        if (member.alive && member.health < member.maxHealth) {
                            const healthPercent = member.health / member.maxHealth;
                            if (healthPercent < mostWounded) {
                                mostWounded = healthPercent;
                                barrierTarget = role;
                            }
                        }
                    }
                    
                    if (barrierTarget) {
                        addBuff(barrierTarget, 'barrier', 4);
                    }
                    break;
                    
                case 'singleMana':
                    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞–Ω—É —Å–æ—é–∑–Ω–∏–∫—É —Å –Ω–∞–∏–º–µ–Ω—å—à–µ–π –º–∞–Ω–æ–π
                    let lowestMana = 100;
                    let manaTarget = null;
                    
                    for (const role in gameState.party) {
                        const member = gameState.party[role];
                        if (member.alive && member.mana < member.maxMana) {
                            const manaPercent = member.mana / member.maxMana;
                            if (manaPercent < lowestMana) {
                                lowestMana = manaPercent;
                                manaTarget = role;
                            }
                        }
                    }
                    
                    if (manaTarget) {
                        const manaAmount = Math.floor(gameState.party[manaTarget].maxMana * 0.5);
                        gameState.party[manaTarget].mana = Math.min(
                            gameState.party[manaTarget].maxMana, 
                            gameState.party[manaTarget].mana + manaAmount
                        );
                    }
                    break;
                    
                case 'groupBuff':
                    // –î–æ–±–∞–≤–ª—è–µ–º –≥—Ä—É–ø–ø–æ–≤–æ–π –±–∞—Ñ—Ñ
                    for (const role in gameState.party) {
                        if (gameState.party[role].alive) {
                            addBuff(role, 'attack', 30);
                            addBuff(role, 'defense', 30);
                        }
                    }
                    break;
                    
                case 'manaRegen':
                    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞–Ω—É –≤—Å–µ–π –≥—Ä—É–ø–ø–µ
                    for (const role in gameState.party) {
                        if (gameState.party[role].alive) {
                            const manaAmount = Math.floor(gameState.party[role].maxMana * 0.25);
                            gameState.party[role].mana = Math.min(
                                gameState.party[role].maxMana, 
                                gameState.party[role].mana + manaAmount
                            );
                        }
                    }
                    break;
                    
                case 'groupShield':
                    // –î–æ–±–∞–≤–ª—è–µ–º –≥—Ä—É–ø–ø–æ–≤–æ–π —â–∏—Ç (–ø–æ–≥–ª–æ—â–µ–Ω–∏–µ –≤—Å–µ–≥–æ —É—Ä–æ–Ω–∞)
                    for (const role in gameState.party) {
                        if (gameState.party[role].alive) {
                            addBuff(role, 'defense', 6);
                        }
                    }
                    break;
                    
                case 'fireball':
                    const fireballEnemies = gameState.enemies.filter(e => e.alive);
                    if (fireballEnemies.length > 0 && !gameState.bossInvulnerable) {
                        const targetEnemy = fireballEnemies[Math.floor(Math.random() * fireballEnemies.length)];
                        const damagePercent = targetEnemy.isBoss ? 0.03 : 0.15;
                        const damage = Math.floor(targetEnemy.maxHealth * damagePercent);
                        targetEnemy.health -= damage;
                        
                        if (targetEnemy.health <= 0) {
                            targetEnemy.alive = false;
                        }
                    }
                    break;
                    
                case 'frostbolt':
                    const frostboltEnemies = gameState.enemies.filter(e => e.alive);
                    if (frostboltEnemies.length > 0 && !gameState.bossInvulnerable) {
                        const targetEnemy = frostboltEnemies[Math.floor(Math.random() * frostboltEnemies.length)];
                        const damagePercent = targetEnemy.isBoss ? 0.04 : 0.20;
                        const damage = Math.floor(targetEnemy.maxHealth * damagePercent);
                        targetEnemy.health -= damage;
                        
                        if (targetEnemy.health <= 0) {
                            targetEnemy.alive = false;
                        }
                    }
                    break;
                    
                case 'lightning':
                    const lightningEnemies = gameState.enemies.filter(e => e.alive);
                    if (lightningEnemies.length > 0 && !gameState.bossInvulnerable) {
                        const targetEnemy = lightningEnemies[Math.floor(Math.random() * lightningEnemies.length)];
                        const damagePercent = targetEnemy.isBoss ? 0.05 : 0.25;
                        const damage = Math.floor(targetEnemy.maxHealth * damagePercent);
                        targetEnemy.health -= damage;
                        
                        if (targetEnemy.health <= 0) {
                            targetEnemy.alive = false;
                        }
                    }
                    break;
                    
                case 'meteor':
                    const meteorEnemies = gameState.enemies.filter(e => e.alive);
                    if (meteorEnemies.length > 0 && !gameState.bossInvulnerable) {
                        const targetEnemy = meteorEnemies[Math.floor(Math.random() * meteorEnemies.length)];
                        const damagePercent = targetEnemy.isBoss ? 0.08 : 0.40;
                        const damage = Math.floor(targetEnemy.maxHealth * damagePercent);
                        targetEnemy.health -= damage;
                        
                        if (targetEnemy.health <= 0) {
                            targetEnemy.alive = false;
                        }
                    }
                    break;
                    
                case 'strike':
                    const strikeEnemies = gameState.enemies.filter(e => e.alive);
                    if (strikeEnemies.length > 0 && !gameState.bossInvulnerable) {
                        const targetEnemy = strikeEnemies[Math.floor(Math.random() * strikeEnemies.length)];
                        const damage = Math.floor(40 * damageMultiplier);
                        targetEnemy.health -= damage;
                        
                        if (targetEnemy.health <= 0) {
                            targetEnemy.alive = false;
                        }
                    }
                    break;
                    
                case 'challenge':
                    const challengeHeal = Math.floor(100 * healingMultiplier);
                    player.health = Math.min(player.maxHealth, player.health + challengeHeal);
                    break;
            }
        }

        // –î–æ–±–∞–≤–∏—Ç—å –±–∞—Ñ—Ñ –ø–µ—Ä—Å–æ–Ω–∞–∂—É
        function addBuff(role, type, duration) {
            if (!gameState.activeBuffs[role]) gameState.activeBuffs[role] = [];
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ —Ç–∞–∫–æ–π –±–∞—Ñ—Ñ
            const existingBuffIndex = gameState.activeBuffs[role].findIndex(buff => buff.type === type);
            
            if (existingBuffIndex >= 0) {
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –±–∞—Ñ—Ñ
                gameState.activeBuffs[role][existingBuffIndex].duration = duration;
            } else {
                // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –±–∞—Ñ—Ñ
                gameState.activeBuffs[role].push({
                    type: type,
                    duration: duration
                });
            }
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è –±–∞—Ñ—Ñ–∞
            const buffKey = `${role}_${type}`;
            gameState.buffTimers[buffKey] = duration;
        }

        // –î–æ–±–∞–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å —ç—Ñ—Ñ–µ–∫—Ç
        function addStatusEffect(role, type, duration, data = {}) {
            if (!gameState.statusEffects[role]) gameState.statusEffects[role] = [];
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —ç—Ñ—Ñ–µ–∫—Ç
            gameState.statusEffects[role].push({
                type: type,
                duration: duration,
                data: data
            });
        }

        // –û–±–Ω–æ–≤–∏—Ç—å –±–∞—Ñ—Ñ—ã
        function updateBuffs() {
            for (const role in gameState.activeBuffs) {
                for (let i = gameState.activeBuffs[role].length - 1; i >= 0; i--) {
                    const buff = gameState.activeBuffs[role][i];
                    const buffKey = `${role}_${buff.type}`;
                    
                    if (gameState.buffTimers[buffKey] !== undefined) {
                        gameState.buffTimers[buffKey]--;
                        
                        if (gameState.buffTimers[buffKey] <= 0) {
                            // –£–¥–∞–ª—è–µ–º –±–∞—Ñ—Ñ
                            gameState.activeBuffs[role].splice(i, 1);
                            delete gameState.buffTimers[buffKey];
                        } else {
                            // –û–±–Ω–æ–≤–ª—è–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ –æ–±—ä–µ–∫—Ç–µ –±–∞—Ñ—Ñ–∞
                            buff.duration = gameState.buffTimers[buffKey];
                        }
                    }
                }
            }
        }

        // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å —ç—Ñ—Ñ–µ–∫—Ç—ã
        function updateStatusEffects() {
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –•–û–¢ —ç—Ñ—Ñ–µ–∫—Ç—ã –∫–∞–∂–¥—ã–µ 3 —Å–µ–∫—É–Ω–¥—ã
            if (gameState.tickCounter % 3 === 0) {
                for (const role in gameState.statusEffects) {
                    for (let i = gameState.statusEffects[role].length - 1; i >= 0; i--) {
                        const effect = gameState.statusEffects[role][i];
                        
                        if (effect.type === 'hot' && gameState.party[role].alive) {
                            // –ü—Ä–∏–º–µ–Ω—è–µ–º –ª–µ—á–µ–Ω–∏–µ –æ—Ç –•–û–¢
                            effect.data.currentTick++;
                            const healAmount = effect.data.healPerTick;
                            gameState.party[role].health = Math.min(
                                gameState.party[role].maxHealth, 
                                gameState.party[role].health + healAmount
                            );
                            
                            // –ï—Å–ª–∏ –≤—Å–µ —Ç–∏–∫–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã, —É–¥–∞–ª—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç
                            if (effect.data.currentTick >= effect.data.ticks) {
                                gameState.statusEffects[role].splice(i, 1);
                            }
                        }
                        
                        // –£–º–µ–Ω—å—à–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —ç—Ñ—Ñ–µ–∫—Ç–∞
                        effect.duration--;
                        
                        // –£–¥–∞–ª—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç, –µ—Å–ª–∏ –≤—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ
                        if (effect.duration <= 0) {
                            gameState.statusEffects[role].splice(i, 1);
                        }
                    }
                }
            }
            
            gameState.tickCounter++;
        }

        // –ü–æ–ª—É—á–∏—Ç—å –∏–∫–æ–Ω–∫—É –±–∞—Ñ—Ñ–∞
        function getBuffIcon(type) {
            switch(type) {
                case 'shield': return 'üõ°Ô∏è';
                case 'barrier': return 'üî∞';
                case 'regen': return 'üíö';
                case 'attack': return '‚öîÔ∏è';
                case 'defense': return 'üõ°Ô∏è';
                case 'dodge': return 'üåÄ';
                default: return '‚ùì';
            }
        }

        // –ü–æ–ª—É—á–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ –±–∞—Ñ—Ñ–∞
        function getBuffDescription(type) {
            switch(type) {
                case 'shield': return '–©–∏—Ç: +50% –∑–∞—â–∏—Ç—ã';
                case 'barrier': return '–ë–∞—Ä—å–µ—Ä: –ü–æ–ª–Ω–∞—è –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å';
                case 'regen': return '–†–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è';
                case 'attack': return '–ê—Ç–∞–∫–∞: +30% —É—Ä–æ–Ω–∞';
                case 'defense': return '–ó–∞—â–∏—Ç–∞: –ü–æ–≥–ª–æ—â–µ–Ω–∏–µ —É—Ä–æ–Ω–∞';
                case 'dodge': return '–£–∫–ª–æ–Ω–µ–Ω–∏–µ: +50%';
                default: return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –±–∞—Ñ—Ñ';
            }
        }

        // –ù–∞—á–∞—Ç—å –¥–∞–Ω–∂
        function startDungeon(dungeonIndex) {
            gameState.currentDungeon = dungeonIndex;
            gameState.currentWave = 0;
            
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –º–Ω–æ–∂–∏—Ç–µ–ª—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–∞–Ω–∂–∞
            gameState.dungeonMultiplier = 1 + (dungeonIndex * 0.15); // +15% HP –∑–∞ –∫–∞–∂–¥—ã–π –¥–∞–Ω–∂
            const damageMultiplier = 1 + (dungeonIndex * 0.05); // +5% —É—Ä–æ–Ω–∞ –∑–∞ –∫–∞–∂–¥—ã–π –¥–∞–Ω–∂
            
            const dungeon = DUNGEONS[dungeonIndex];
            document.getElementById('currentDungeon').textContent = dungeon.name;
            
            nextWave(damageMultiplier);
        }

        // –°–ª–µ–¥—É—é—â–∞—è –≤–æ–ª–Ω–∞ –≤—Ä–∞–≥–æ–≤
        function nextWave(damageMultiplier = 1) {
            gameState.currentWave++;
            const dungeon = DUNGEONS[gameState.currentDungeon];
            
            if (gameState.currentWave > dungeon.waves) {
                // –î–∞–Ω–∂ –ø—Ä–æ–π–¥–µ–Ω
                completeDungeon();
                return;
            }
            
            // –°–æ–∑–¥–∞–µ–º –≤—Ä–∞–≥–æ–≤ –¥–ª—è –≤–æ–ª–Ω—ã
            gameState.enemies = [];
            const enemyCount = dungeon.enemiesPerWave;
            
            // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω—è—è –≤–æ–ª–Ω–∞ –∏ –µ—Å—Ç—å –±–æ—Å—Å
            if (gameState.currentWave === dungeon.waves && dungeon.boss) {
                const bossHealth = Math.floor((500 + gameState.currentDungeon * 100) * gameState.dungeonMultiplier);
                const bossDamage = Math.floor((30 + gameState.currentDungeon * 10) * damageMultiplier);
                
                gameState.enemies.push({
                    id: 0,
                    name: '–ë–æ—Å—Å',
                    health: bossHealth,
                    maxHealth: bossHealth,
                    damage: bossDamage,
                    alive: true,
                    target: null,
                    isBoss: true
                });
                gameState.bossInvulnerable = false;
                gameState.bossInvulnerableTimer = 0;
            } else {
                for (let i = 0; i < enemyCount; i++) {
                    const enemyHealth = Math.floor((80 + gameState.currentWave * 20) * gameState.dungeonMultiplier);
                    const enemyDamage = Math.floor((10 + gameState.currentWave * 3) * damageMultiplier);
                    
                    gameState.enemies.push({
                        id: i,
                        name: '–í—Ä–∞–≥',
                        health: enemyHealth,
                        maxHealth: enemyHealth,
                        damage: enemyDamage,
                        alive: true,
                        target: null,
                        isBoss: false
                    });
                }
            }
            
            document.getElementById('currentWave').textContent = gameState.currentWave;
            document.getElementById('nextDungeon').disabled = true;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
            updateEnemiesUI();
        }

        // –ò–ò –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≥—Ä—É–ø–ø–æ–π
        function updateAI() {
            for (const role in gameState.party) {
                if (role === gameState.playerRole) continue;
                
                const member = gameState.party[role];
                if (!member.alive) continue;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∫—É–ª–¥–∞—É–Ω—ã —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π –ò–ò
                member.abilities.forEach(ability => {
                    if (ability.currentCooldown > 0) {
                        ability.currentCooldown--;
                    }
                });
                
                // –õ–æ–≥–∏–∫–∞ –ò–ò –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–æ–ª–∏
                switch(role) {
                    case ROLES.TANK:
                        // –¢–∞–Ω–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—Ä–æ–≤–æ–∫–∞—Ü–∏—é, –µ—Å–ª–∏ –≤—Ä–∞–≥–∏ –∞—Ç–∞–∫—É—é—Ç –Ω–µ –µ–≥–æ
                        let enemiesTargetingTank = 0;
                        gameState.enemies.forEach(enemy => {
                            if (enemy.target === 'tank') enemiesTargetingTank++;
                        });
                        
                        if (enemiesTargetingTank < gameState.enemies.length / 2) {
                            const tauntAbility = member.abilities.find(a => a.id === 'taunt');
                            if (tauntAbility && tauntAbility.currentCooldown === 0 && member.mana >= tauntAbility.cost) {
                                gameState.enemies.forEach(enemy => {
                                    enemy.target = 'tank';
                                });
                                member.mana -= tauntAbility.cost;
                                tauntAbility.currentCooldown = tauntAbility.cooldown;
                            }
                        }
                        
                        // –¢–∞–Ω–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —â–∏—Ç, –µ—Å–ª–∏ –∑–¥–æ—Ä–æ–≤—å–µ –Ω–∏–∑–∫–æ–µ
                        if (member.health < member.maxHealth * 0.5) {
                            const shieldAbility = member.abilities.find(a => a.id === 'shield');
                            if (shieldAbility && shieldAbility.currentCooldown === 0 && member.mana >= shieldAbility.cost) {
                                member.mana -= shieldAbility.cost;
                                shieldAbility.currentCooldown = shieldAbility.cooldown;
                                addBuff(member.role, 'shield', 8);
                            }
                        }
                        
                        // –¢–∞–Ω–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —É–¥–∞—Ä, –µ—Å–ª–∏ –µ—Å—Ç—å –º–∞–Ω–∞
                        const strikeAbility = member.abilities.find(a => a.id === 'strike');
                        if (strikeAbility && strikeAbility.currentCooldown === 0 && member.mana >= strikeAbility.cost && !gameState.bossInvulnerable) {
                            const aliveEnemies = gameState.enemies.filter(e => e.alive);
                            if (aliveEnemies.length > 0) {
                                const targetEnemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
                                const damageMultiplier = 1 + (gameState.upgrades.damage.level * gameState.upgrades.damage.effect);
                                const damage = Math.floor(40 * damageMultiplier);
                                targetEnemy.health -= damage;
                                member.mana -= strikeAbility.cost;
                                strikeAbility.currentCooldown = strikeAbility.cooldown;
                                
                                if (targetEnemy.health <= 0) {
                                    targetEnemy.alive = false;
                                }
                            }
                        }
                        break;
                        
                    case ROLES.HEALER:
                        // –•–∏–ª–µ—Ä –∏—â–µ—Ç —Å–∞–º–æ–≥–æ —Ä–∞–Ω–µ–Ω–æ–≥–æ —Å–æ—é–∑–Ω–∏–∫–∞
                        let lowestHealth = 100;
                        let healTarget = null;
                        
                        for (const r in gameState.party) {
                            const m = gameState.party[r];
                            if (m.alive && m.health < m.maxHealth) {
                                const healthPercent = m.health / m.maxHealth;
                                if (healthPercent < lowestHealth) {
                                    lowestHealth = healthPercent;
                                    healTarget = r;
                                }
                            }
                        }
                        
                        // –ï—Å–ª–∏ –µ—Å—Ç—å —Ä–∞–Ω–µ–Ω—ã–π —Å–æ—é–∑–Ω–∏–∫, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ª–µ—á–µ–Ω–∏–µ
                        if (healTarget && lowestHealth < 0.7) {
                            const healAbility = member.abilities.find(a => a.id === 'heal');
                            if (healAbility && healAbility.currentCooldown === 0 && member.mana >= healAbility.cost) {
                                const healingMultiplier = 1 + (gameState.upgrades.healing.level * gameState.upgrades.healing.effect);
                                const healAmount = Math.floor(60 * healingMultiplier);
                                gameState.party[healTarget].health = Math.min(
                                    gameState.party[healTarget].maxHealth, 
                                    gameState.party[healTarget].health + healAmount
                                );
                                member.mana -= healAbility.cost;
                                healAbility.currentCooldown = healAbility.cooldown;
                                
                                // –î–æ–±–∞–≤–ª—è–µ–º –•–û–¢ —ç—Ñ—Ñ–µ–∫—Ç
                                addStatusEffect(healTarget, 'hot', 3, { 
                                    ticks: 3, 
                                    healPerTick: Math.floor(gameState.party[healTarget].maxHealth * 0.02) + 40,
                                    currentTick: 0 
                                });
                            }
                        }
                        
                        // –ï—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–Ω–µ–Ω—ã—Ö, –∏—Å–ø–æ–ª—å–∑—É–µ–º –≥—Ä—É–ø–ø–æ–≤–æ–µ –ª–µ—á–µ–Ω–∏–µ
                        let woundedCount = 0;
                        for (const r in gameState.party) {
                            if (gameState.party[r].alive && gameState.party[r].health < gameState.party[r].maxHealth * 0.8) {
                                woundedCount++;
                            }
                        }
                        
                        if (woundedCount >= 2) {
                            const groupHealAbility = member.abilities.find(a => a.id === 'groupHeal');
                            if (groupHealAbility && groupHealAbility.currentCooldown === 0 && member.mana >= groupHealAbility.cost) {
                                const groupHealingMultiplier = 1 + (gameState.upgrades.healing.level * gameState.upgrades.healing.effect);
                                const groupHealAmount = Math.floor(40 * groupHealingMultiplier);
                                for (const r in gameState.party) {
                                    if (gameState.party[r].alive) {
                                        gameState.party[r].health = Math.min(
                                            gameState.party[r].maxHealth, 
                                            gameState.party[r].health + groupHealAmount
                                        );
                                    }
                                }
                                member.mana -= groupHealAbility.cost;
                                groupHealAbility.currentCooldown = groupHealAbility.cooldown;
                            }
                        }
                        
                        // –•–∏–ª–µ—Ä –≤–æ—Å–∫—Ä–µ—à–∞–µ—Ç –º–µ—Ä—Ç–≤—ã—Ö —Å–æ—é–∑–Ω–∏–∫–æ–≤
                        let deadTarget = null;
                        for (const r in gameState.party) {
                            if (!gameState.party[r].alive) {
                                deadTarget = r;
                                break;
                            }
                        }
                        
                        if (deadTarget) {
                            const resurrectAbility = member.abilities.find(a => a.id === 'resurrect');
                            if (resurrectAbility && resurrectAbility.currentCooldown === 0 && member.mana >= resurrectAbility.cost) {
                                gameState.party[deadTarget].alive = true;
                                gameState.party[deadTarget].health = gameState.party[deadTarget].maxHealth * 0.3;
                                gameState.party[deadTarget].mana = gameState.party[deadTarget].maxMana * 0.5;
                                member.mana -= resurrectAbility.cost;
                                resurrectAbility.currentCooldown = resurrectAbility.cooldown;
                            }
                        }
                        
                        // –•–∏–ª–µ—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –±–∞—Ä—å–µ—Ä –Ω–∞ —Å–∞–º–æ–≥–æ —Ä–∞–Ω–µ–Ω–æ–≥–æ
                        if (lowestHealth < 0.3) {
                            const barrierAbility = member.abilities.find(a => a.id === 'barrier');
                            if (barrierAbility && barrierAbility.currentCooldown === 0 && member.mana >= barrierAbility.cost) {
                                member.mana -= barrierAbility.cost;
                                barrierAbility.currentCooldown = barrierAbility.cooldown;
                                addBuff(healTarget, 'barrier', 4);
                            }
                        }
                        break;
                        
                    case ROLES.SUPPORT:
                        // –°–∞–ø–ø–æ—Ä—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≥—Ä—É–ø–ø–æ–≤–æ–π –±–∞—Ñ—Ñ, –µ—Å–ª–∏ –æ–Ω –¥–æ—Å—Ç—É–ø–µ–Ω
                        const groupBuffAbility = member.abilities.find(a => a.id === 'groupBuff');
                        if (groupBuffAbility && groupBuffAbility.currentCooldown === 0 && member.mana >= groupBuffAbility.cost) {
                            member.mana -= groupBuffAbility.cost;
                            groupBuffAbility.currentCooldown = groupBuffAbility.cooldown;
                            for (const r in gameState.party) {
                                if (gameState.party[r].alive) {
                                    addBuff(r, 'attack', 30);
                                    addBuff(r, 'defense', 30);
                                }
                            }
                        }
                        
                        // –°–∞–ø–ø–æ—Ä—Ç –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –º–∞–Ω—É —Ç–æ–º—É, —É –∫–æ–≥–æ –µ—ë –º–∞–ª–æ
                        let lowestMana = 100;
                        let manaTarget = null;
                        
                        for (const r in gameState.party) {
                            const m = gameState.party[r];
                            if (m.alive && m.mana < m.maxMana) {
                                const manaPercent = m.mana / m.maxMana;
                                if (manaPercent < lowestMana) {
                                    lowestMana = manaPercent;
                                    manaTarget = r;
                                }
                            }
                        }
                        
                        if (manaTarget && lowestMana < 0.5) {
                            const singleManaAbility = member.abilities.find(a => a.id === 'singleMana');
                            if (singleManaAbility && singleManaAbility.currentCooldown === 0 && member.mana >= singleManaAbility.cost) {
                                const manaAmount = Math.floor(gameState.party[manaTarget].maxMana * 0.5);
                                gameState.party[manaTarget].mana = Math.min(
                                    gameState.party[manaTarget].maxMana, 
                                    gameState.party[manaTarget].mana + manaAmount
                                );
                                member.mana -= singleManaAbility.cost;
                                singleManaAbility.currentCooldown = singleManaAbility.cooldown;
                            }
                        }
                        
                        // –°–∞–ø–ø–æ—Ä—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≥—Ä—É–ø–ø–æ–≤–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∞–Ω—ã
                        let lowManaCount = 0;
                        for (const r in gameState.party) {
                            if (gameState.party[r].alive && gameState.party[r].mana < gameState.party[r].maxMana * 0.7) {
                                lowManaCount++;
                            }
                        }
                        
                        if (lowManaCount >= 2) {
                            const manaRegenAbility = member.abilities.find(a => a.id === 'manaRegen');
                            if (manaRegenAbility && manaRegenAbility.currentCooldown === 0 && member.mana >= manaRegenAbility.cost) {
                                member.mana -= manaRegenAbility.cost;
                                manaRegenAbility.currentCooldown = manaRegenAbility.cooldown;
                                for (const r in gameState.party) {
                                    if (gameState.party[r].alive) {
                                        const manaAmount = Math.floor(gameState.party[r].maxMana * 0.25);
                                        gameState.party[r].mana = Math.min(
                                            gameState.party[r].maxMana, 
                                            gameState.party[r].mana + manaAmount
                                        );
                                    }
                                }
                            }
                        }
                        
                        // –°–∞–ø–ø–æ—Ä—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≥—Ä—É–ø–ø–æ–≤–æ–π —â–∏—Ç, –µ—Å–ª–∏ –≥—Ä—É–ø–ø–∞ –ø–æ–ª—É—á–∞–µ—Ç –º–Ω–æ–≥–æ —É—Ä–æ–Ω–∞
                        let totalHealthPercent = 0;
                        let aliveCount = 0;
                        for (const r in gameState.party) {
                            if (gameState.party[r].alive) {
                                totalHealthPercent += gameState.party[r].health / gameState.party[r].maxHealth;
                                aliveCount++;
                            }
                        }
                        const averageHealth = totalHealthPercent / aliveCount;
                        
                        if (averageHealth < 0.6) {
                            const groupShieldAbility = member.abilities.find(a => a.id === 'groupShield');
                            if (groupShieldAbility && groupShieldAbility.currentCooldown === 0 && member.mana >= groupShieldAbility.cost) {
                                member.mana -= groupShieldAbility.cost;
                                groupShieldAbility.currentCooldown = groupShieldAbility.cooldown;
                                for (const r in gameState.party) {
                                    if (gameState.party[r].alive) {
                                        addBuff(r, 'defense', 6);
                                    }
                                }
                            }
                        }
                        break;
                        
                    case ROLES.MAGE:
                        // –ú–∞–≥ –∞—Ç–∞–∫—É–µ—Ç –≤—Ä–∞–≥–æ–≤
                        const aliveEnemies = gameState.enemies.filter(e => e.alive);
                        if (aliveEnemies.length > 0 && !gameState.bossInvulnerable) {
                            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º —É—Ä–æ–Ω–æ–º –≤ –ø–µ—Ä–≤—É—é –æ—á–µ—Ä–µ–¥—å
                            const abilitiesByPower = [
                                { id: 'meteor', priority: 4 },
                                { id: 'lightning', priority: 3 },
                                { id: 'frostbolt', priority: 2 },
                                { id: 'fireball', priority: 1 }
                            ];
                            
                            for (const abilityInfo of abilitiesByPower) {
                                const ability = member.abilities.find(a => a.id === abilityInfo.id);
                                if (ability && ability.currentCooldown === 0 && member.mana >= ability.cost) {
                                    const targetEnemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
                                    const damagePercent = targetEnemy.isBoss ? 
                                        (abilityInfo.priority * 0.02) : 
                                        (abilityInfo.priority * 0.05 + 0.1);
                                    const damage = Math.floor(targetEnemy.maxHealth * damagePercent);
                                    targetEnemy.health -= damage;
                                    member.mana -= ability.cost;
                                    ability.currentCooldown = ability.cooldown;
                                    
                                    if (targetEnemy.health <= 0) {
                                        targetEnemy.alive = false;
                                    }
                                    break;
                                }
                            }
                        }
                        break;
                }
                
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞–Ω—É –ò–ò (–ø–∞—Å—Å–∏–≤–Ω–∞—è —Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è)
                member.mana = Math.min(member.maxMana, member.mana + 10);
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
        function updateEnemies() {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–π–º–µ—Ä –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç–∏ –±–æ—Å—Å–∞
            if (gameState.bossInvulnerable) {
                gameState.bossInvulnerableTimer--;
                if (gameState.bossInvulnerableTimer <= 0) {
                    gameState.bossInvulnerable = false;
                }
            } else {
                // –°–ª—É—á–∞–π–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å –±–æ—Å—Å–∞ (5% —à–∞–Ω—Å –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É)
                const boss = gameState.enemies.find(e => e.isBoss && e.alive);
                if (boss && Math.random() < 0.05) {
                    gameState.bossInvulnerable = true;
                    gameState.bossInvulnerableTimer = 5; // 5 —Å–µ–∫—É–Ω–¥
                }
            }
            
            for (let i = 0; i < gameState.enemies.length; i++) {
                const enemy = gameState.enemies[i];
                if (!enemy.alive) continue;
                
                // –ï—Å–ª–∏ —É –≤—Ä–∞–≥–∞ –Ω–µ—Ç —Ü–µ–ª–∏, –≤—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∂–∏–≤–æ–≥–æ —á–ª–µ–Ω–∞ –≥—Ä—É–ø–ø—ã
                if (!enemy.target) {
                    const roles = Object.keys(gameState.party);
                    const aliveRoles = roles.filter(role => gameState.party[role].alive);
                    if (aliveRoles.length > 0) {
                        enemy.target = aliveRoles[Math.floor(Math.random() * aliveRoles.length)];
                    }
                }
                
                // –ï—Å–ª–∏ —Ü–µ–ª—å –º–µ—Ä—Ç–≤–∞, –≤—ã–±–∏—Ä–∞–µ–º –Ω–æ–≤—É—é
                if (enemy.target && !gameState.party[enemy.target].alive) {
                    const roles = Object.keys(gameState.party);
                    const aliveRoles = roles.filter(role => gameState.party[role].alive);
                    if (aliveRoles.length > 0) {
                        enemy.target = aliveRoles[Math.floor(Math.random() * aliveRoles.length)];
                    } else {
                        enemy.target = null;
                    }
                }
                
                // –ê—Ç–∞–∫—É–µ–º —Ü–µ–ª—å
                if (enemy.target && gameState.party[enemy.target].alive) {
                    const target = gameState.party[enemy.target];
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞—Ñ—Ñ—ã –∑–∞—â–∏—Ç—ã
                    let damageMultiplier = 1;
                    let hasBarrier = false;
                    
                    if (gameState.activeBuffs[target.role]) {
                        for (const buff of gameState.activeBuffs[target.role]) {
                            if (buff.type === 'shield') {
                                damageMultiplier *= 0.5; // 50% —Å–Ω–∏–∂–µ–Ω–∏–µ —É—Ä–æ–Ω–∞
                            } else if (buff.type === 'barrier') {
                                hasBarrier = true; // –ü–æ–ª–Ω–∞—è –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å
                            } else if (buff.type === 'defense') {
                                damageMultiplier = 0; // –ü–æ–≥–ª–æ—â–µ–Ω–∏–µ –≤—Å–µ–≥–æ —É—Ä–æ–Ω–∞
                            }
                        }
                    }
                    
                    // –ë–æ—Å—Å –∞—Ç–∞–∫—É–µ—Ç —Ä–µ–∂–µ, –Ω–æ —Å–∏–ª—å–Ω–µ–µ
                    const attackChance = enemy.isBoss ? 0.5 : 0.7;
                    if (Math.random() < attackChance && !hasBarrier) {
                        const damage = Math.floor(enemy.damage * damageMultiplier);
                        
                        if (damage > 0) {
                            target.health -= damage;
                        }
                        
                        if (target.health <= 0) {
                            target.alive = false;
                            target.health = 0;
                            
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—Å–µ –ª–∏ –º–µ—Ä—Ç–≤—ã
                            checkGameOver();
                        }
                    }
                }
            }
            
            // –£–¥–∞–ª—è–µ–º –º–µ—Ä—Ç–≤—ã—Ö –≤—Ä–∞–≥–æ–≤
            gameState.enemies = gameState.enemies.filter(enemy => enemy.alive);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
            updateEnemiesUI();
            
            // –ï—Å–ª–∏ –≤—Å–µ –≤—Ä–∞–≥–∏ –º–µ—Ä—Ç–≤—ã, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –≤–æ–ª–Ω–µ
            if (gameState.enemies.length === 0) {
                setTimeout(() => {
                    nextWave();
                }, 2000);
            }
        }

        // –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function gameLoop() {
            if (!gameState.gameActive) return;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫—É–ª–¥–∞—É–Ω—ã —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π –∏–≥—Ä–æ–∫–∞
            for (const abilityId in gameState.abilityCooldowns) {
                if (gameState.abilityCooldowns[abilityId] > 0) {
                    gameState.abilityCooldowns[abilityId]--;
                }
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞—Ñ—Ñ—ã
            updateBuffs();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —ç—Ñ—Ñ–µ–∫—Ç—ã
            updateStatusEffects();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ò–ò –≥—Ä—É–ø–ø—ã
            updateAI();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–∞–≥–æ–≤
            updateEnemies();
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞–Ω—É –∏–≥—Ä–æ–∫–∞ (–ø–∞—Å—Å–∏–≤–Ω–∞—è —Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è)
            const player = gameState.party[gameState.playerRole];
            if (player.alive) {
                player.mana = Math.min(player.maxMana, player.mana + 10);
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
            updatePartyUI();
            updateEnemiesUI();
            updatePlayerAbilitiesUI();
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –≥—Ä—É–ø–ø—ã
        function updatePartyUI() {
            const partyDisplay = document.getElementById('partyDisplay');
            partyDisplay.innerHTML = '';
            
            for (const role in gameState.party) {
                const member = gameState.party[role];
                const memberElement = document.createElement('div');
                memberElement.className = `party-member ${member.alive ? '' : 'dead-member'}`;
                
                const healthPercent = (member.health / member.maxHealth) * 100;
                const manaPercent = (member.mana / member.maxMana) * 100;
                
                // –°–æ–∑–¥–∞–µ–º HTML –¥–ª—è –±–∞—Ñ—Ñ–æ–≤
                let buffsHTML = '';
                if (gameState.activeBuffs[role] && gameState.activeBuffs[role].length > 0) {
                    buffsHTML = '<div class="buffs">';
                    gameState.activeBuffs[role].forEach(buff => {
                        const buffClass = `buff ${buff.type}`;
                        const buffIcon = getBuffIcon(buff.type);
                        const buffDescription = getBuffDescription(buff.type);
                        buffsHTML += `
                            <div class="${buffClass}">
                                ${buffIcon}
                                <div class="buff-tooltip">${buffDescription} (${buff.duration}—Å)</div>
                            </div>
                        `;
                    });
                    buffsHTML += '</div>';
                }
                
                // –°–æ–∑–¥–∞–µ–º HTML –¥–ª—è —Å—Ç–∞—Ç—É—Å —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
                let statusHTML = '';
                if (gameState.statusEffects[role] && gameState.statusEffects[role].length > 0) {
                    statusHTML = '<div class="status-effects">';
                    gameState.statusEffects[role].forEach(effect => {
                        const statusClass = `status-effect ${effect.type === 'hot' ? 'status-hot' : 'status-dot'}`;
                        const statusIcon = effect.type === 'hot' ? 'üíö' : 'üíÄ';
                        statusHTML += `<div class="${statusClass}">${statusIcon}</div>`;
                    });
                    statusHTML += '</div>';
                }
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è —ç—Ç–æ–≥–æ —á–ª–µ–Ω–∞ –≥—Ä—É–ø–ø—ã
                let actionsHTML = '';
                const player = gameState.party[gameState.playerRole];
                
                if (player.role === ROLES.HEALER && member.alive && role !== gameState.playerRole) {
                    actionsHTML = `
                        <button class="member-action" data-action="heal" data-target="${role}">
                            <div class="action-icon">‚ù§Ô∏è</div>
                            <div class="action-name">–õ–µ—á–µ–Ω–∏–µ</div>
                            <div class="action-details">60 HP</div>
                        </button>
                        <button class="member-action" data-action="barrier" data-target="${role}">
                            <div class="action-icon">üî∞</div>
                            <div class="action-name">–ë–∞—Ä—å–µ—Ä</div>
                            <div class="action-details">4 —Å–µ–∫</div>
                        </button>
                    `;
                } else if (player.role === ROLES.SUPPORT && member.alive && role !== gameState.playerRole) {
                    actionsHTML = `
                        <button class="member-action" data-action="singleMana" data-target="${role}">
                            <div class="action-icon">‚ú®</div>
                            <div class="action-name">–ú–∞–Ω–∞</div>
                            <div class="action-details">50% MP</div>
                        </button>
                    `;
                } else if (!member.alive && (player.role === ROLES.HEALER || player.role === ROLES.SUPPORT)) {
                    actionsHTML = `
                        <button class="member-action" data-action="resurrect" data-target="${role}">
                            <div class="action-icon">‚≠ê</div>
                            <div class="action-name">–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å</div>
                        </button>
                    `;
                } else {
                    actionsHTML = `
                        <div class="member-action" style="visibility: hidden;"></div>
                        <div class="member-action" style="visibility: hidden;"></div>
                    `;
                }
                
                memberElement.innerHTML = `
                    <div class="member-header">
                        <div class="member-name">${member.name}</div>
                        <div class="member-role">${getRoleName(member.role)}</div>
                    </div>
                    <div class="health-bar">
                        <div class="health-fill" style="width: ${healthPercent}%"></div>
                        <div class="health-text">${Math.floor(member.health)}/${member.maxHealth}</div>
                    </div>
                    <div class="mana-bar">
                        <div class="mana-fill" style="width: ${manaPercent}%"></div>
                        <div class="mana-text">${Math.floor(member.mana)}/${member.maxMana}</div>
                    </div>
                    ${buffsHTML}
                    ${statusHTML}
                    <div class="member-actions">
                        ${actionsHTML}
                    </div>
                    <div class="abilities">
                        ${member.abilities.map(ability => `
                            <div class="ability ${ability.currentCooldown === 0 ? 'ready' : 'on-cooldown'}">
                                ${ability.icon}
                                ${ability.currentCooldown > 0 ? `<div class="cooldown-overlay">${ability.currentCooldown}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
                
                partyDisplay.appendChild(memberElement);
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –¥–µ–π—Å—Ç–≤–∏–π —á–ª–µ–Ω–æ–≤ –≥—Ä—É–ø–ø—ã
            document.querySelectorAll('.member-action').forEach(button => {
                button.addEventListener('click', function() {
                    const action = this.getAttribute('data-action');
                    const target = this.getAttribute('data-target');
                    executeMemberAction(action, target);
                });
            });
        }

        // –í—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞ —á–ª–µ–Ω–∞ –≥—Ä—É–ø–ø—ã
        function executeMemberAction(action, targetRole) {
            const player = gameState.party[gameState.playerRole];
            
            switch(action) {
                case 'heal':
                    if (player.mana >= 25) {
                        const healAmount = 60;
                        gameState.party[targetRole].health = Math.min(
                            gameState.party[targetRole].maxHealth, 
                            gameState.party[targetRole].health + healAmount
                        );
                        player.mana -= 25;
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –•–û–¢ —ç—Ñ—Ñ–µ–∫—Ç
                        addStatusEffect(targetRole, 'hot', 3, { 
                            ticks: 3, 
                            healPerTick: Math.floor(gameState.party[targetRole].maxHealth * 0.02) + 40,
                            currentTick: 0 
                        });
                    }
                    break;
                    
                case 'barrier':
                    if (player.mana >= 60) {
                        addBuff(targetRole, 'barrier', 4);
                        player.mana -= 60;
                    }
                    break;
                    
                case 'singleMana':
                    if (player.mana >= 30) {
                        const manaAmount = Math.floor(gameState.party[targetRole].maxMana * 0.5);
                        gameState.party[targetRole].mana = Math.min(
                            gameState.party[targetRole].maxMana, 
                            gameState.party[targetRole].mana + manaAmount
                        );
                        player.mana -= 30;
                    }
                    break;
                    
                case 'resurrect':
                    if (player.mana >= 100) {
                        gameState.party[targetRole].alive = true;
                        gameState.party[targetRole].health = gameState.party[targetRole].maxHealth * 0.3;
                        gameState.party[targetRole].mana = gameState.party[targetRole].maxMana * 0.5;
                        player.mana -= 100;
                    }
                    break;
            }
            
            updatePartyUI();
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è —Ä–æ–ª–∏
        function getRoleName(role) {
            switch(role) {
                case ROLES.TANK: return '–¢–∞–Ω–∫';
                case ROLES.HEALER: return '–•–∏–ª–µ—Ä';
                case ROLES.SUPPORT: return '–°–∞–ø–ø–æ—Ä—Ç';
                case ROLES.MAGE: return '–ú–∞–≥';
                default: return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –≤—Ä–∞–≥–æ–≤
        function updateEnemiesUI() {
            const enemiesDisplay = document.getElementById('enemiesDisplay');
            enemiesDisplay.innerHTML = '';
            
            gameState.enemies.forEach(enemy => {
                const enemyElement = document.createElement('div');
                enemyElement.className = `enemy ${enemy.isBoss ? 'boss' : ''} ${gameState.bossInvulnerable && enemy.isBoss ? 'invulnerable' : ''}`;
                
                const healthPercent = (enemy.health / enemy.maxHealth) * 100;
                
                enemyElement.innerHTML = `
                    <div class="enemy-header">
                        <div class="enemy-name">${enemy.name}</div>
                        <div class="enemy-type">${enemy.isBoss ? '–ë–û–°–°' : '–í—Ä–∞–≥'}</div>
                    </div>
                    <div class="enemy-health">
                        <div class="health-fill" style="width: ${healthPercent}%"></div>
                        <div class="health-text">${Math.floor(enemy.health)}/${enemy.maxHealth}</div>
                    </div>
                    ${gameState.bossInvulnerable && enemy.isBoss ? '<div style="text-align: center; font-size: 11px; color: #ffd700; margin-top: 5px;">–ù–ï–£–Ø–ó–í–ò–ú!</div>' : ''}
                `;
                
                enemiesDisplay.appendChild(enemyElement);
            });
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π –∏–≥—Ä–æ–∫–∞
        function updatePlayerAbilitiesUI() {
            const player = gameState.party[gameState.playerRole];
            const abilityElements = document.querySelectorAll('.player-ability');
            
            abilityElements.forEach(element => {
                const abilityId = element.getAttribute('data-ability');
                const cooldown = gameState.abilityCooldowns[abilityId];
                const ability = player.abilities.find(a => a.id === abilityId);
                
                if (cooldown > 0) {
                    element.classList.add('on-cooldown');
                    
                    let cooldownOverlay = element.querySelector('.player-cooldown');
                    if (!cooldownOverlay) {
                        cooldownOverlay = document.createElement('div');
                        cooldownOverlay.className = 'player-cooldown';
                        element.appendChild(cooldownOverlay);
                    }
                    cooldownOverlay.textContent = cooldown;
                } else {
                    element.classList.remove('on-cooldown');
                    
                    const cooldownOverlay = element.querySelector('.player-cooldown');
                    if (cooldownOverlay) {
                        element.removeChild(cooldownOverlay);
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ö–≤–∞—Ç–∞–µ—Ç –ª–∏ –º–∞–Ω—ã
                if (player.mana < ability.cost) {
                    element.style.opacity = '0.5';
                } else {
                    element.style.opacity = '1';
                }
            });
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏—è –ø–æ—Ä–∞–∂–µ–Ω–∏—è
        function checkGameOver() {
            let aliveCount = 0;
            for (const role in gameState.party) {
                if (gameState.party[role].alive) {
                    aliveCount++;
                }
            }
            
            if (aliveCount === 0) {
                gameOver();
            }
        }

        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –¥–∞–Ω–∂–∞
        function completeDungeon() {
            const dungeon = DUNGEONS[gameState.currentDungeon];
            gameState.currency += dungeon.reward;
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥—Ä—É–ø–ø—É
            for (const role in gameState.party) {
                const member = gameState.party[role];
                if (member.alive) {
                    member.health = member.maxHealth;
                    member.mana = member.maxMana;
                }
            }
            
            document.getElementById('currencyAmount').textContent = gameState.currency;
            document.getElementById('nextDungeon').disabled = false;
            
            // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–∞–Ω–∂, –Ω–∞—á–∏–Ω–∞–µ–º —Å–Ω–∞—á–∞–ª–∞ —Å —É–≤–µ–ª–∏—á–µ–Ω–Ω–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç—å—é
            if (gameState.currentDungeon >= DUNGEONS.length - 1) {
                gameState.currentDungeon = 0;
            }
            
            updatePartyUI();
        }

        // –°–ª–µ–¥—É—é—â–∏–π –¥–∞–Ω–∂
        function nextDungeon() {
            gameState.currentDungeon++;
            if (gameState.currentDungeon >= DUNGEONS.length) {
                gameState.currentDungeon = 0;
            }
            
            startDungeon(gameState.currentDungeon);
        }

        // –û—Ç–∫—Ä—ã—Ç–∏–µ –º–∞–≥–∞–∑–∏–Ω–∞
        function openShop() {
            gameState.gameActive = false;
            
            document.getElementById('shopCurrencyAmount').textContent = gameState.currency;
            
            const upgradesContainer = document.getElementById('upgrades');
            upgradesContainer.innerHTML = '';
            
            for (const upgradeId in gameState.upgrades) {
                const upgrade = gameState.upgrades[upgradeId];
                const upgradeElement = document.createElement('div');
                upgradeElement.className = 'upgrade';
                upgradeElement.setAttribute('data-upgrade', upgradeId);
                
                // –í—ã—á–∏—Å–ª—è–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å —Å —É—á–µ—Ç–æ–º —É—Ä–æ–≤–Ω—è (–∫–∞–∂–¥–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ –≤ 2 —Ä–∞–∑–∞ –¥–æ—Ä–æ–∂–µ)
                const actualCost = upgrade.cost * Math.pow(2, upgrade.level);
                
                upgradeElement.innerHTML = `
                    <div class="upgrade-icon">${getUpgradeIcon(upgradeId)}</div>
                    <div class="upgrade-name">${getUpgradeName(upgradeId)}</div>
                    <div class="upgrade-desc">${upgrade.description}</div>
                    <div class="upgrade-cost">${actualCost} –∑–æ–ª–æ—Ç—ã—Ö</div>
                    <div class="upgrade-level">–£—Ä–æ–≤–µ–Ω—å: ${upgrade.level}${upgrade.maxLevel === 999 ? '+' : `/${upgrade.maxLevel}`}</div>
                `;
                
                if (upgrade.level < upgrade.maxLevel) {
                    upgradeElement.addEventListener('click', function() {
                        buyUpgrade(upgradeId, actualCost);
                    });
                } else {
                    upgradeElement.style.opacity = '0.5';
                    upgradeElement.style.cursor = 'not-allowed';
                }
                
                upgradesContainer.appendChild(upgradeElement);
            }
            
            switchScreen('shopScreen');
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–∫–æ–Ω–∫–∏ —É–ª—É—á—à–µ–Ω–∏—è
        function getUpgradeIcon(upgradeId) {
            switch(upgradeId) {
                case 'health': return '‚ù§Ô∏è';
                case 'mana': return 'üîµ';
                case 'damage': return '‚öîÔ∏è';
                case 'healing': return 'üíñ';
                case 'cooldown': return '‚è±Ô∏è';
                case 'manaCost': return 'üîã';
                default: return '‚ùì';
            }
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è —É–ª—É—á—à–µ–Ω–∏—è
        function getUpgradeName(upgradeId) {
            switch(upgradeId) {
                case 'health': return '–£–≤–µ–ª–∏—á–µ–Ω–∏–µ –∑–¥–æ—Ä–æ–≤—å—è';
                case 'mana': return '–£–≤–µ–ª–∏—á–µ–Ω–∏–µ –º–∞–Ω—ã';
                case 'damage': return '–£–≤–µ–ª–∏—á–µ–Ω–∏–µ —É—Ä–æ–Ω–∞';
                case 'healing': return '–£–ª—É—á—à–µ–Ω–∏–µ –ª–µ—á–µ–Ω–∏—è';
                case 'cooldown': return '–°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏';
                case 'manaCost': return '–°–Ω–∏–∂–µ–Ω–∏–µ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –º–∞–Ω—ã';
                default: return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
            }
        }

        // –ü–æ–∫—É–ø–∫–∞ —É–ª—É—á—à–µ–Ω–∏—è
        function buyUpgrade(upgradeId, cost) {
            if (gameState.currency < cost) {
                alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–æ–ª–æ—Ç–∞!');
                return;
            }
            
            gameState.currency -= cost;
            gameState.upgrades[upgradeId].level++;
            
            document.getElementById('shopCurrencyAmount').textContent = gameState.currency;
            document.getElementById('currencyAmount').textContent = gameState.currency;
            
            // –ü–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥—Ä—É–ø–ø—É —Å –Ω–æ–≤—ã–º–∏ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞–º–∏
            initParty();
            initPlayerAbilities();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–≥–∞–∑–∏–Ω
            openShop();
        }

        // –í–æ–∑–≤—Ä–∞—Ç –∫ –∏–≥—Ä–µ –∏–∑ –º–∞–≥–∞–∑–∏–Ω–∞
        function backToGame() {
            gameState.gameActive = true;
            switchScreen('gameScreen');
        }

        // –ö–æ–Ω–µ—Ü –∏–≥—Ä—ã
        function gameOver() {
            gameState.gameActive = false;
            clearInterval(gameState.gameLoopInterval);
            
            document.getElementById('dungeonsCompleted').textContent = gameState.currentDungeon;
            switchScreen('gameOverScreen');
        }

        // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        function restartGame() {
            // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
            gameState = {
                playerRole: gameState.playerRole,
                party: {},
                enemies: [],
                currentDungeon: 0,
                currentWave: 0,
                currency: 50,
                gameActive: false,
                abilityCooldowns: {},
                playerAbilities: [],
                upgrades: {},
                gameLoopInterval: null,
                bossInvulnerable: false,
                bossInvulnerableTimer: 0,
                dungeonMultiplier: 1,
                activeBuffs: {},
                buffTimers: {},
                statusEffects: {},
                tickCounter: 0
            };
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–ª—É—á—à–µ–Ω–∏–π
            initUpgrades();
            
            // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
            startGame();
        }

        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–æ–≤
        function switchScreen(screenId) {
            const screens = document.querySelectorAll('.screen');
            screens.forEach(screen => {
                screen.classList.remove('active');
            });
            
            document.getElementById(screenId).classList.add('active');
        }
    </script>
</body>
</html>
